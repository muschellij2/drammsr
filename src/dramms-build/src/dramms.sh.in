#! /bin/bash

##############################################################################
# @file  dramms.sh
# @brief Deformable Registration via Attribute Matching and Mutual-Saliency weighting
#
# Copyright (c) 2011-2013 University of Pennsylvania. All rights reserved.
#               2014-2016 Massachusetts General Hospital, Harvard Medical School.
#		2016-     Boston Childrens Hospital, Harvard Medical School.                                   
# See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
#
# Contact: Yangming Ou <yangming.ou@mgh.harvard.edu>
#          SBIA Group <sbia-software at uphs.upenn.edu>
##############################################################################

. ${BASIS_BASH_UTILITIES} || { echo "Failed to source BASIS utilities!" 1>&2; exit 1; }


############################################
#
### Help
#
############################################

print_help_short()
{
    local EXENAME && exename EXENAME
    echo "Usage:"
    echo "  $EXENAME -S <inputA.nii> -T <inputB.nii> -O <outimgA2B.nii> -D <outdefA2B.nii.gz> [options]"
    echo "  or,"
    echo "  $EXENAME --source <inputA.nii> --target <inputB.nii> --outimg <outimgA2B.nii> --outdef <outdefA2B.nii.gz> [options]"
    echo
    echo "Description:"
    echo "  This program registers two input images (both 2D or both 3D), outputs the deformed image and the deformation field."
    echo "  This script can also calculate RAVENS maps, Jacobian maps and warp another image from the obtained deformation."
    echo ""
    echo "  Accepted image formats are ANALYZE or Nifti. Accepted image datatype include byte, short(signed or unsigned)"
    echo "  float, and int32."
    echo
    echo "Required input arguments:"
    echo "  -S, --source  <char>    Source/Subject  image file."
    echo "  -T, --target  <char>    Target/Template image file."
    echo
    echo "(Optional) output arguments:"
    echo "  -O, --outimg  <char>    Output image file. The output image will be in the target space. Exception: when RAVENS"
    echo "                          calculation (-R option) is activated, the output image will be in the source space, but RAVENS."
    echo "                          maps will be in the target space."
    echo "  -D  --outdef  <char>    Output deformation field. It is in the target image space. It can be used to map (warp) other "
    echo "                          images from the source space to the target space. "
    echo
    echo "Standard options:"  
    echo "  -v, --verbose           Increase verbosity of output messages. Give twice (-v -v) for more verbose output."
    echo "  -V, --version           Print version information and exit."
    echo "  -h, --help              Print more options (parameters and Ravens/Jacobian/Warp functions)."
    echo
    echo "Example: "
    echo "  Register image A to image B using default settings."
    echo "      $EXENAME --source A.hdr  --target B.nii --outimg A2B.img --outdef B2A_def.nii.gz"
    echo ""
    echo "  Show more options for parameter settings and Warping/Jacobian/RAVENS usages."
    echo "      $EXENAME --help"
    echo
    print_contact
}



print_help_detail()
{
    local EXENAME && exename EXENAME
    echo "Usage:"
    echo "  $EXENAME -S <inputA.nii> -T <inputB.nii> -O <outimgA2B.nii> -D <outdefA2B.nii.gz> [options]"
    echo "  or,"
    echo "  $EXENAME --source <inputA.nii> --target <inputB.nii> --outimg <outimgA2B.nii> --outdef <outdefA2B.nii.gz> [options]"
    echo
    echo "Description:"
    echo "  This program registers two input images (both 2D or both 3D), outputs deformed image and deformation field."
    echo "  This script can also calculate RAVENS maps, Jacobian maps and warp another image from obtained deformation."
    echo
    echo "  Accepted image formats are ANALYZE or Nifti. Accepted image datatype include byte, short(signed or unsigned)"
    echo "  float, and int32."
    echo ""
    echo ""
    echo "Required Input Arguments:"
    echo "  -S, --source  <char>    Source/Subject  image file."
    echo "  -T, --target  <char>    Target/Template image file."
    echo ""
    echo ""
    echo "(Optional) Output Arguments:"
    echo "  -O, --outimg  <char>    Output image file. The output image will be in the target space. Exception: when RAVENS"
    echo "                          calculation (-R option) is activated, the output image will be in the source space, but RAVENS."
    echo "                          maps will be in the target space."
    echo "  -D  --outdef  <char>    Output deformation field. It is in the targt space. It can be used to map (warp) other images "
    echo "                          from the source space to the target space. "
    echo ""
    echo ""
    echo "Optional Parameters For the Deformation Model:"
    echo "  -x   <int>              FFD spacing in X direction (the number of voxels between two adjacent control points in X direction)."
    echo "                          Larger spacing captures larger deformations; smaller spacing leads to higher accuracy in local"
    echo "                          matching. (default: max([imageSizeX/50] 3) )"
    echo "  -y   <int>              FFD spacing in Y direction (the number of voxels between two adjacent control points in Y direction)."
    echo "                          Larger spacing captures larger deformations; smaller spacing leads to higher accuracy in local matching."
    echo "                          (default: max([imageSizeY/50] 3) )"
    echo "  -z   <int>              FFD spacing in Z direction (the number of voxels between two adjacent control points in X direction)."
    echo "                          Larger spacing captures larger deformations; smaller spacing leads to higher accuracy in local matching."
    echo "                          (default: max([imageSizeZ/60] 1) )"
    echo ""
    echo ""
    echo "Optional Parameters For Similarity Defintion:"
    echo "  -s   <int>              The number of scales for Gabor attributes (default: 3)"
    echo "  -o   <int>              The number of orientations for Gabor attributes (default: 4)"
    echo "  -c   <int>              How to use mutual-saliency weighting. "
    echo "                          0 -- (default) do not use mutual-saliency if there are no outlier regions (lesions, cuts, etc);"
    echo "                          1 -- use but do not save mutual-saliency map; "
    echo "                          2 -- use and save mutual-saliency map as \${outimg_folder}/MutualSaliency-\${outputprefix}.nii.gz"
    echo "  -w   <int>              Similarity measure: "
    echo "                          0 -- SSD: sum of squared difference of attributes (default). Proper for mono-modal registrations."
    echo "                          1 -- NCC: normalized correlation coefficient of attributes. This can be used for mono- and multi-modal registrations."
    echo "                          2 -- CR: correlation ratio of attributes (32 bins). This can be used for mono- and multi-modal registrations"
    echo "  -M                      Force histogram matching"
    echo "                          (default: off -- the program will automatically decide whether to match histogram.)"
    echo ""
    echo ""
    echo "To Mask Out Certain Outlier Regions (Cost-Function-Masking):"
    echo "  --bt  <char>            Binary mask for foreground in the *target* space. Only deform in the non-zero area in the mask."
    echo "                          The given mask must be in the byte datatype. (default: NULL)"
    echo "  --bs  <char>            Binary mask for foreground in the *source* space. Only deform in the non-zero area in the mask."
    echo "                          The given mask must be in the byte datatype. (default: NULL)"
    echo ""
    echo ""
    echo "Optional Parameters For Discrete Optimization (only effective for 3D registration):"
    echo "  -g   <float>            Regularization weight, usually 0~1 with larger value for smoother deformation."
    echo "                          (default: 0.2  for registration"
    echo "                                    0.15 for warping ROI (-W option)"
    echo "                                    0.3  for RAVENS calculation (-R option))"
    echo "  -n   <int>              The number of discrete samples in the discrete optimization."
    echo "                          Larger value means denser sampling, hence more computational time and increased accuracy."
    echo "                          (default: 5)"
    echo "  -k   <int>              The maximum number of iterations at each resolution. (default: 10)"
    echo "  -H   <int>              Rate to convert from global sraech to local search. (default: 0.5)"
    echo "  -m   <int>              Interpolation of displacement at ordinary from control points."
    echo "                          0-nearest neighbor; 1-trilinear; 2-cubic B-spline (default: 1)"
    echo "  -f                      Request fast approximation only. If on, the program will finish faster with"
    echo "                          less smooth deformation."
    echo "  -e   <int>              Addition (0) or composition (1) of deformations. (default: 0)"
    echo "  -t   <int>              Threshold for generating foreground mask for attribute extraction and for deformation."
    echo "                          (default: 0)"
    echo ""
    echo ""
    echo "To Enable/Disable Affine/Rigid:"
    echo "  -a   <int>              Control of transformation models: "
    echo "                          0 -- no affine/rigid registration, only deformable registration"
    echo "                          1 -- (default) affine followed by deformable, will output a unified/concatenated deformation field"
    echo "                          2 -- affine only, will output a transformed image (specified by the '-O' option) "
    echo "                               and an affine matrix (specified by the '-D' option);"
    echo "                          3 -- rigid followed by deformable, will output a unifid/concatenated deformation field"
    echo "                          4 -- rigid only, will output a transformed image (specified by the '-O' option) "
    echo "                               and an rigid matrix (specified by the '-D' option);"
    echo ""
    echo ""
    echo "To Control Memory Consumption:"
    echo "  -u   <int>              How much memory to use. "
    echo "                          3 -- most memory for highest possible accuracy (default); "
    echo "                          2 -- less memory for slightly less accuracy; "
    echo "                          1 -- even less memory, a bit more decrease in accuracy; "
    echo "                          0 -- the least amount of memory, but relatively big decrease in accuracy."
    echo ""
    echo ""
    echo "To Input an Initial Transformation:"
    echo "  -d   <char>             Initial transformation. "
    echo "                          can be an initial affine transformation (in the *.mat file format, flirt convention), "
    echo "                          or"
    echo "                          can be an initial deformation (in the *.nii.gz file format, dramms convention)."
    echo "                          (default: NULL)"
    echo ""
    echo ""
    echo "To Save Intermediate Files for Debug:"
    echo "  -i                      Save intermediate results"
    echo "                          into a user-specified directory as specified by the '-I' option,"
    echo "                          or, "
    echo "                          into an auto-generated and unique directory in the current folder, if '-I' option is not used."
    echo "  -I   <char>             Use with -i to save intermediate results in a user-specified directory. "
    echo ""
    echo ""
    echo "To Calculate Jacobian Determinant Immediately Following Deformation Calculation:"
    echo "  -J   <char>             Output Jacobian determinant image."
    echo ""
    echo ""
    echo "To Calculate RAVENS Maps Immediately Following Deformation Calculation:"
    echo "  -R   <char>             Prefix of the output RAVENS maps. RAVENS maps will be saved with file basename"
    echo "                          \${Prefix}_\${TissueLabel} for each tissue label given by -l option. Maps will"
    echo "                          be saved as signed short datatype with a default scaling factor of 1000."
    echo "                          When this option is given, the -L and -l options must be specified."
    echo "  -L   <char>             Input tissue label map (in subject space). Required if -R option given."
    echo "  -l   <int>[,<int>...]   Specify up to 5 tissue labels in the label map. Required if -R option given."
    echo ""
    echo ""
    echo "To Warp Another Image Immediately Following Deformation Calculation:"
    echo "  -W   <char>             Name of the warped image (will be in the target space)."
    echo "  -L   <char>             Input image (in the source space) to be warped, such as a label map or a functional image."
    echo "  -r   <int>              Interpolation method when warping image: 0-neareast neighbor; 1-trilinear; 2-sinc (one-side neigborhood size = 5voxels). (default: 1)"
    echo ""
    echo ""
    echo "Standard Options:"  
    echo "  -v, --verbose           Increase verbosity of output messages. Give twice (-v -v) for more verbose output."
    echo "  -V, --version           Print version information and exit."
    echo "  -h, --help              Print more options (parameters and Ravens/Jacobian/Warp functions)."
    echo
    echo "Example: "
    echo "  Register image A to image B using default settings."
    echo "      $EXENAME --source A.hdr  --target B.nii --outimg A2B.img --outdef B2A_def.nii.gz"
    echo ""
    echo "  Show more options for parameter settings and Warping/Jacobian/RAVENS usages."
    echo "      $EXENAME --help"
    echo
    print_contact
}

# show help if called without arguments
[ $# -eq 0 ] && print_help_short && exit 1

############################################
#
### Constants
#
############################################

export FSLOUTPUTTYPE=NIFTI_GZ   # have flirt output .nii.gz
export PATH=/bin:/usr/bin:$PATH # ensure that bc of system is used
                                # note that, for example, the IRTK includes a
                                # a program for bias correction named bc!
                                # http://www.doc.ic.ac.uk/~dr/software/

# avoid POSIXLY_CORRECT to change to default BASH environment, which the rest of the dramms code is based on. Thanks to Keith Bartley for reporting this issue.	
if [ ${POSIXLY_CORRECT} ]; then				
	unset ${POSIXLY_CORRECT} 
fi

timeProgramBegin=`date +%s` # time when program started

############################################
#
### Auxiliary functions
#
############################################

# ----------------------------------------------------------------------------
# get image file name without extension
prefix()
{
    local prefix=$1
    prefix=${prefix%.hdr}
    prefix=${prefix%.hdr.gz}
    prefix=${prefix%.img}
    prefix=${prefix%.img.gz}
    prefix=${prefix%.nii}
    prefix=${prefix%.nii.gz}
    prefix=${prefix%.mhd}
    prefix=${prefix%.raw}
    prefix=${prefix%.raw.gz}
    echo -n "${prefix}"
}

# ----------------------------------------------------------------------------
# execute subprocess
run()
{
    if [ ${verbose} -gt 0 ]; then
        execute -v $(( verbose - 1 )) -- "$@"
    else
        execute -v $(( verbose - 1 )) -- "$@" > /dev/null # discard stdout of subprocess
    fi
}

# ----------------------------------------------------------------------------
# print error message
#
# @param [in] msg Error message to print to stderr.
error() { echo "Error: $1" 1>&2; }

# ----------------------------------------------------------------------------
# clean up on exit
trap cleanup EXIT INT QUIT TERM
cleanup()
{
    if [ -n ${tmpdir} ] && [ ${keepIntermediateResultsOrNot} -eq 0 ]; then
        \rm -rf ${tmpdir}
    fi	

    if [ ${flag_step6} == 1 ]; then
	    errormemoryshortage 1>&2
    fi
}


# ----------------------------------------------------------------------------
# error memory shortage
errormemoryshortage()
{
    red='\e[0;31m'
    NC='\e[0m' # No Color

	echo ""
    echo "----------"
    echo -e "${red}Error:"
    echo -e "Computation of Deformation failed. This is usually casued by the lack of sufficient memory."
    echo -e ""
	echo -e "To estimate how much memory your images may require: http://www.cbica.upenn.edu/sbia/software/dramms/download.html#system-requirements"
	echo -e ""
	echo -e "In general, please re-run with 12GB (in rare cases 14GB) memory available."
	echo -e ""
	echo -e "If your machine does not have that much memory, you can still run dramms using much less memory (at the cost of slighlty reduced accuracy): http://www.cbica.upenn.edu/sbia/software/dramms/faq.html#q4 $NC{}"
	echo -e ""
    echo "----------"
	echo ""
}


# ----------------------------------------------------------------------------
# regularization for linear registration
calculatepenalty()
{
        transform=$1
        a11=`cat $transform | sed -n 1p | awk '{ print $1 }'`
        a12=`cat $transform | sed -n 1p | awk '{ print $2 }'`
        a13=`cat $transform | sed -n 1p | awk '{ print $3 }'`
        a21=`cat $transform | sed -n 2p | awk '{ print $1 }'`
        a22=`cat $transform | sed -n 2p | awk '{ print $2 }'`
        a23=`cat $transform | sed -n 2p | awk '{ print $3 }'`
        a31=`cat $transform | sed -n 3p | awk '{ print $1 }'`
        a32=`cat $transform | sed -n 3p | awk '{ print $2 }'`
        a33=`cat $transform | sed -n 3p | awk '{ print $3 }'`

        # added on 5/16/2017, some version of flirt output a  matrix in scientific numbers, this added section is to convert them into floating numbers
        a11=`printf '%5.5f' $a11 | tr -d -`
        a12=`printf '%5.5f' $a12 | tr -d -`
        a13=`printf '%5.5f' $a13 | tr -d -`
        a21=`printf '%5.5f' $a21 | tr -d -`
        a22=`printf '%5.5f' $a22 | tr -d -`
        a23=`printf '%5.5f' $a23 | tr -d -`
        a31=`printf '%5.5f' $a31 | tr -d -`
        a32=`printf '%5.5f' $a32 | tr -d -`
        a33=`printf '%5.5f' $a33 | tr -d -`

        # sometimes an affine element may in the form of ??e-??, which means it is very close to 0
        if [ -z "${a11##*e*}" ] ;then a11=0; fi
        if [ -z "${a12##*e*}" ] ;then a12=0; fi
        if [ -z "${a13##*e*}" ] ;then a13=0; fi
        if [ -z "${a21##*e*}" ] ;then a21=0; fi
        if [ -z "${a22##*e*}" ] ;then a22=0; fi
        if [ -z "${a23##*e*}" ] ;then a23=0; fi
        if [ -z "${a31##*e*}" ] ;then a31=0; fi
        if [ -z "${a32##*e*}" ] ;then a32=0; fi
        if [ -z "${a33##*e*}" ] ;then a33=0; fi

        if [ `echo ${a11} '>' ${a12} | bc -l` == 1 ]; then a1=${a11}; else a1=${a12}; fi
        if [ `echo ${a1}  '>' ${a13} | bc -l` == 1 ]; then a1=${a1};  else a1=${a13}; fi
        if [ `echo ${a21} '>' ${a22} | bc -l` == 1 ]; then a2=${a21}; else a2=${a22}; fi
        if [ `echo ${a2}  '>' ${a23} | bc -l` == 1 ]; then a2=${a2};  else a2=${a23}; fi
        if [ `echo ${a31} '>' ${a32} | bc -l` == 1 ]; then a3=${a31}; else a3=${a32}; fi
        if [ `echo ${a3}  '>' ${a33} | bc -l` == 1 ]; then a3=${a3};  else a3=${a33}; fi

        penalty=`echo "(1 - ${a1})*(1 - ${a2})*(1 - ${a3})" | bc -l`

        echo ${penalty} | tr -d -
}


############################################
#
### Parse command-line arguments
#
############################################

verbose=0 # verbosity of output messages

# ----------------------------------------------------------------------------
# required arguments for input files
inputImgA='NULL'
inputImgB='NULL'

# ----------------------------------------------------------------------------
# optional argumenst for output files
outputImgA2B='NULL'
deformationFieldA2B='NULL'

# ----------------------------------------------------------------------------
# optional arguments for input initialization
inputmaskt='NULL'
inputmasks='NULL'
inputmask='NULL'
initTransformation='NULL'
initAffineMatrix='NULL'
initDeformation='NULL'

# ----------------------------------------------------------------------------
# optional parameters 
affineOrNot=1                     # whether to perform affine registration, 0: no; 1: yes, then deformable (default); 2: yes, then stop and output.
distBetweenControlPointsX=0       # will be determined automatically if set to less or equal to 0
distBetweenControlPointsY=0       # will be determined automatically if set to less or equal to 0
distBetweenControlPointsZ=0       # will be determined automatically if set to less or equal to 0
useMemory=2                       # level 0 (least memory usage, lowest registration accuracy) to 3 (most memory usage, highest registration accuracy).
numGaborScales=3 
numGaborOrientations=4 
numDiscreteSamples=5 
maxNumIterInEachResolution=10 
label_factor=0.50  #0.67 
manipulationMethod=1              # 0: NN, 1: trilinear, 2: cubic B-spline
regularizationWeight=-1           # will be determined automatically if set to '-1'
mutualSaliencyOrNot=0
keepIntermediateResultsOrNot=0    # 0: remove them, 1: keep them
foregroundThre=0 #12                 # after intensities have been normalized into [0,255] range
fastApproximationOrNot=0
additionOrComposition=0
matchHistogramFlag=0
similarityMeasure=0               # 0: SSD, 1: NCC, 2: CR

# ----------------------------------------------------------------------------
# optional arguments for user-specific intermediate directory
intermediateResultsDir=           # directory for intermediate results

# ----------------------------------------------------------------------------
# optional arguments for Jacobian calculation
Jacobian='NULL'

# ----------------------------------------------------------------------------
# optional arguments for RAVENS calculation
RAVENS='NULL'
LabelMap='NULL'     # a user must input this when -R option is used to calculate RAENS
labelValues=99999   # a user must input this when -R option is used to calculate RAENS

# ----------------------------------------------------------------------------
# optional arguments for warping
WarpedImage='NULL'
interpolationWarp=1 # interpolation when warping another image, 1: trilinear, 0: nearest neighbor

# ----------------------------------------------------------------------------
# flag for whether we are in step 6 (calculation of deformation)
flag_step6=0

# ----------------------------------------------------------------------------
# parse user input 
checkarg()
{
    if [[ "X$2" == 'X' ]]; then
        echo "Option $1 requires an argument!" 1>&2
        echo "See --help for usage information." 1>&2
        exit 1
    fi
}

setarg()
{
    if [[ ${#1} -gt 2 ]] && [[ "${1:0:1}" == '-' ]] ; then
        echo -n "${1:2: -1}"
    elif [[ "X$2" == 'X' ]]; then
        echo "Option $1 requires an argument!" 1>&2
        echo "See --help for usage information." 1>&2
        exit 1
    fi
}

while [[ $# -gt 0 ]]; do
    opt="$1"
    arg="$2"
    nshift=2
    # allow both "-a 1" and "-a1", therefore, split $1 in option flag and argument
    if [[ ${#opt} -gt 2 ]] && [[ "${opt:0:1}" == '-' ]] && [[ "${opt:1:1}" != '-' ]] ; then
        arg="${opt:2}"
        opt="${opt:0:2}"
        nshift=1 # $2 is the next option, so don't process it yet
    fi
    case "$opt" in
        # -------------------------------------------
        # required arguments
        -S|--source) checkarg $opt $arg; inputImgA="$arg";;
        -T|--target) checkarg $opt $arg; inputImgB="$arg";;
        # -------------------------------------------
        # optional arguments for output
        -O|--outimg) checkarg $opt $arg; outputImgA2B="$arg";;
        -D|--outdef) checkarg $opt $arg; deformationFieldA2B="$arg";;
        # -------------------------------------------
        # optional arguments for registration parameters
        -a) checkarg $opt $arg; affineOrNot="$arg";;
        -x) checkarg $opt $arg; distBetweenControlPointsY="$arg";;
        -y) checkarg $opt $arg; distBetweenControlPointsX="$arg";;
        -z) checkarg $opt $arg; distBetweenControlPointsZ="$arg";;
		-u) checkarg $opt $arg; useMemory="$arg";;
		-M) matchHistogramFlag=1; nshift=1;;
        -s) checkarg $opt $arg; numGaborScales="$arg";;
        -o) checkarg $opt $arg; numGaborOrientations="$arg";;
        -n) checkarg $opt $arg; numDiscreteSamples="$arg";;
        -k) checkarg $opt $arg; maxNumIterInEachResolution="$arg";;
        -H) checkarg $opt $arg; label_factor="$arg";;
        -m) checkarg $opt $arg; manipulationMethod="$arg";;
        -g) checkarg $opt $arg; regularizationWeight="$arg";;
        -c) checkarg $opt $arg; mutualSaliencyOrNot="$arg";;
        -i) keepIntermediateResultsOrNot=1; nshift=1;;
		-I) checkarg $opt $arg; intermediateResultsDir="$arg";;
        -t) checkarg $opt $arg; foregroundThre="$arg";;
        -f) fastApproximationOrNot=1; nshift=1;;
        -e) checkarg $opt $arg; additionOrComposition="$arg";;
        -w) checkarg $opt $arg; similarityMeasure="$arg";;
		# -------------------------------------------
        # optional arguments for input initialization
        --bt) checkarg $opt $arg; inputmaskt="$arg";;
	--bs) checkarg $opt $arg; inputmasks="$arg";;
        -d) checkarg $opt $arg; initTransformation="$arg";;
        # -------------------------------------------
        # optional arguments for Jacobian calculation
        -J) checkarg $opt $arg; Jacobian="$arg";;
        # -------------------------------------------
        # optional arguments for RAVENS calculation
        -R) checkarg $opt $arg; RAVENS="$arg";;
        -L) checkarg $opt $arg; LabelMap="$arg";;
        -l) checkarg $opt $arg; labelValues="$arg";;
        # -------------------------------------------
        # optional arguments for Warping Image
        -W) checkarg $opt $arg; WarpedImage="$arg";;
        -r) checkarg $opt $arg; interpolationWarp="$arg";;
        # -------------------------------------------
        # optional arguments for software information
        -v|--verbose) (( verbose++ )); nshift=1;;
        -V|--version) print_version 'dramms' --copyright '2011--2013 UPenn; 2014--2016 MGH, HMS; 2016-- BCH, HMS.'; exit 0;;
        -h|--help) print_help_detail; exit 0;;
        *)
            echo "Invalid option $1!" 1>&2
            echo "See --help for usage information." 1>&2
            exit 1
            ;;
    esac
    shift ${nshift}
done

# ----------------------------------------------------------------------------
# automatically determine registration direction based on whether RAVENS maps
# will be calculated the registration is always from subject to template except
# in case of RAVENS calculation

if [ ${inputImgA} == 'NULL' ]; then
    echo
    error "No subject image specified!"
    echo
    exit 1
fi
if [ ${inputImgB} == 'NULL' ]; then
    echo
    error "No template image specified!"
    echo
    exit 1
fi

if [ $RAVENS != 'NULL' ]; then
    bridgeVal=${inputImgA}
    inputImgA=${inputImgB}
    inputImgB=${bridgeVal}
fi

function readlink2 {
    xout=`readlink -f ${inputImgA}`
    if [ "$?" != "0" ]; then
        xout=`greadlink -f ${inputImgA}`;
    fi
    echo ${xout}
}

inputImgA=`readlink2 ${inputImgA} 2> /dev/null`;
inputImgA_basename=`basename ${inputImgA}`
inputImgA_path=`realpath ${inputImgA}`
inputImgA_path=`dirname ${inputImgA_path}`
inputImgA_fullname=${inputImgA_path}/${inputImgA_basename}
inputImgA_prefix=`prefix ${inputImgA_basename}`
if [ ! -f ${inputImgA} ]; then
	echo -e "\nError: input image ${inputImgA} does not exist. Please double check. Program exits.\n"
	exit 1
fi

inputImgB=`readlink2 ${inputImgB} 2> /dev/null`
inputImgB_basename=`basename ${inputImgB}`
inputImgB_path=`realpath ${inputImgB}`
inputImgB_path=`dirname ${inputImgB_path}`
inputImgB_fullname=${inputImgB_path}/${inputImgB_basename}
inputImgB_prefix=`prefix ${inputImgB_basename}`
if [ ! -f ${inputImgB} ]; then
	echo -e "\nError: input image ${inputImgB} does not exist. Please double check. Program exits.\n"
	exit 1
fi

############################################
#
### Create temporary directories
#
############################################

[[ -n "${intermediateResultsDir}" ]] && intermediateResultsDir=`abspath "${intermediateResultsDir}"`

# make temporary directory
currentDIR=`pwd`
if [ ${keepIntermediateResultsOrNot} -eq 1 ]; then
    if [[ -n "${intermediateResultsDir}" ]]; then
        tmpdir="${intermediateResultsDir}"
        [[ -d "${tmpdir}" ]] || mkdir -p "${tmpdir}"
    else
        tmpdir=`mktemp -d "${currentDIR}/dramms-${inputImgA_prefix}_to_${inputImgB_prefix}-XXXXXX"`
    fi
elif [[ -n "${intermediateResultsDir}" ]]; then
    tmpdir=`mktemp -d "${intermediateResultsDir}/dramms-XXXXXX"`
elif [[ -n "${SBIA_TMPDIR}" ]]; then
    tmpdir=`mktemp -d "${SBIA_TMPDIR}/dramms-XXXXXX"`
elif [[ -n "${TMPDIR}" ]]; then
    tmpdir=`mktemp -d "${TMPDIR}/dramms-XXXXXX"`
else
    tmpdir=`mktemp -d /tmp/dramms-XXXXXX`
fi
sysflag=`echo $?`
if [ ${sysflag} -ne 0 ]; then
    echo
    error "Failed to make a temporary directory!"
    echo
    exit 1
fi
tmpdir=`abspath ${tmpdir}`

# make subdirectories for different intermediate results
attributeDIR=${tmpdir}/features
run mkdir -p ${attributeDIR}
sysflag=`echo $?`
[ ${sysflag} -eq 0 ] || {
    echo
    error "Failed to create directory ${attributeDIR}!"
    echo
    exit 1
}

intermediateDIR=${tmpdir}/intermediate
run mkdir -p ${intermediateDIR}
sysflag=`echo $?`
[ ${sysflag} -eq 0 ] || {
    echo
    error "Failed to create directory ${intermediateDIR}!"
    echo
    exit 1
}

############################################
#
### Check command-line arguments
#
############################################

# ----------------------------------------------------------------------------
# check 1: two input images should be in the same space if no affine/rigid registration is requested
if [ $affineOrNot == "0" ]; then
    execute --allow_fail -- CheckTwoImages ${inputImgA} ${inputImgB} > /dev/null
	sysflag=`echo $?`
    if [ ${sysflag} -eq 255 ]; then
        echo
        error "Failed to read header of image ${inputImgA} or ${inputImgB}!"
        echo
        exit 1
    elif [ ${sysflag} -eq 0 ]; then
        echo
        error "The two input images have not been affinely registered, i.e., they are not in the same space yet."
        error "Please affinely register the images or execute dramms again using the '-a 1' option so it does it for you."
        echo
        exit 1
    fi
    number_of_dimensions=${sysflag}
    if [ ${verbose} -gt 0 ]; then
        echo "The input images reside in a common ${number_of_dimensions}D space."
    fi
fi


# ----------------------------------------------------------------------------
# check 3: if the name of output (registered) image and/or deformation are not given, use randomly-generated names
if [ ${outputImgA2B} == 'NULL' ]; then
    outputImgA2B=${tmpdir}/A2B.nii.gz
fi
outputImgA2B_basename=`basename ${outputImgA2B}`;
outputImgA2B_path=`realpath ${outputImgA2B}`
outputImgA2B_path=`dirname ${outputImgA2B_path}`
outputImgA2B_fullname=${outputImgA2B_path}/${outputImgA2B_basename};

if [ ${deformationFieldA2B} == 'NULL' ]; then
    deformationFieldA2B=${tmpdir}/def_A2B.nii.gz
fi
deformationFieldA2B_basename=`basename ${deformationFieldA2B}`;
deformationFieldA2B_path=`realpath ${deformationFieldA2B}`
deformationFieldA2B_path=`dirname ${deformationFieldA2B_path}`
deformationFieldA2B_fullname=${deformationFieldA2B_path}/${deformationFieldA2B_basename}

prefixA2B=`prefix ${outputImgA2B_basename}`

if [ -z ${outputImgA2B_path} ] || [ -z ${deformationFieldA2B_path} ]; then
    echo
    error 'The given directories to store output image and/or output deformation to do not exist!'
    echo
    exit 1
fi


# ----------------------------------------------------------------------------
# check 4: if initial mask is given, need to make sure it exists, and in the same space of template image
if [ $inputmaskt != 'NULL' ]; then  
    execute --allow_fail -- CheckTwoImages ${inputImgB} ${inputmaskt} > /dev/null
    sysflag=`echo $?`
    if [ ${sysflag} -eq 255 ]; then
        echo
        error "Failed to read header of image ${inputImgB} or mask ${inputmaskt}!"
        echo
        exit 1
    elif [ ${sysflag} -eq 0 ]; then
        echo
        error "Input mask specified by '--bt' must be defined in the space of target image ${inputImgB}!"
	error "This requries that they should have *exactly the same* image size, and voxel size. "
        error "Please double check or use '--bs' if the input mask is in the source image space."
        echo
    fi

    inputmaskt=`readlink2 ${inputmaskt}`
    inputmaskt_basename=`basename ${inputmaskt}`
    inputmaskt_path=`realpath ${inputmaskt}`
    inputmaskt_path=`dirname ${inputmaskt_path}`
    inputmaskt_fullname=${inputmaskt_path}/${inputmaskt_basename}
    if [ ! -f ${inputmaskt} ]; then
	echo -e "\nError: input mask file ${inputmaskt} does not exist. Program exits.\n"
	exit 1
    fi
    inputmask=${inputmaskt}
    inputmask_fullname=${inputmaskt_fullname}
fi
if [ $inputmasks != 'NULL' ]; then  
    execute --allow_fail -- CheckTwoImages ${inputImgA} ${inputmasks} > /dev/null
    sysflag=`echo $?`
    if [ ${sysflag} -eq 255 ]; then
        echo
        error "Failed to read header of image ${inputImgA} or mask ${inputmasks}!"
        echo
        exit 1
    elif [ ${sysflag} -eq 0 ]; then
        echo
        error "Input mask specified by '--bs' must be defined in the space of source image ${inputImgA}!"
	error "This requries that they should have *exactly the same* image size, and voxel size. "
        error "Please double check or use '--bt' if the input mask is in the target image space."
        echo
    fi

    inputmasks=`readlink2 ${inputmasks}`
    inputmasks_basename=`basename ${inputmasks}`
    inputmasks_path=`realpath ${inputmasks}`
    inputmasks_path=`dirname ${inputmasks_path}`
    inputmasks_fullname=${inputmasks_path}/${inputmasks_basename}
    if [ ! -f ${inputmasks} ]; then
	echo -e "\nError: input mask file ${inputmasks} does not exist. Program exits.\n"
	exit 1
    fi
    inputmask=${inputmasks}
fi
if [ ${inputmasks} != 'NULL' ]&&[ ${inputmaskt} != 'NULL' ]; then
	echo -e "\nError: you can use either '--bt' or '--bs' option, but not both!\nProgram exits.\n\n"
	exit 1
fi
	 

# ----------------------------------------------------------------------------
# check 5: if an initial transformation is given, need to make sure 
#          1. first, whether it exists, and whether it is an affine transformation or a deformation
#          2. if an initial affine transformation
#             2.1) it should be in the flirt format (.mat extension, and 0 0 0 1 in the last row)
#          2. if an initial deformation
#             2.1) it is in the same space of template image; 
#             2.2) it has N displacement components (moving in N-D space, where N is the dimension of the image)
if [ $initTransformation != 'NULL' ]; then 
    # check 5-1
    if [ ! -f ${initTransformation} ]; then
	  echo ""
	  echo "error: the input initial transformation (${initTransformation}) does not exist."
	  echo "program terminated."
	  echo ""
	  exit 1
    fi
    extension4=${initTransformation: -4}
    extension7=${initTransformation: -7}
    if [ ${extension4} == ".mat" ]; then
	    initAffineMatrix=${initTransformation}
    elif [ ${extension4} == ".nii" ]||[ ${extension4} == ".hdr" ]||[ ${extension4} == ".img" ]||[ ${extension7} == ".nii.gz" ]; then
	    initDeformation=${initTransformation}
    else
	    echo ""
	    echo "error: the initial transformation by the '-d' option must be either a flirt-convension affine matrix (with a .mat extension) or a dramms-convention deformation field (with a .nii.gz/.hdr/.img/.nii extension)."
	    echo "program terminated."
	    echo ""
	    exit 1
    fi

    # if an affine matrix
    if [ ${initAffineMatrix} != 'NULL' ]; then
	    affineOrNot=0  # no need to re-do affine
	    initAffineMatrix=`readlink2 ${initAffineMatrix}`
	    initAffineMatrix_basename=`basename ${initAffineMatrix}`
	    initAffineMatrix_path=`realpath ${initAffineMatrix}`
	    initAffineMatrix_path=`dirname ${initAffineMatrix_path}`
	    initAffineMatrix_fullname=${initAffineMatrix_path}/${initAffineMatrix_basename}
	    if [ ! -f ${initAffineMatrix} ]; then
		echo -e "\nError: input initial transformation ${initAffineMatrix} does not exist. Program exits.\n"
		exit 1
	    fi
    fi

	    
    # if a deformation
    if [ ${initDeformation} != 'NULL' ]; then
	    # check 5-2.1
	    execute --allow_fail -- CheckTwoImages ${inputImgB} ${initDeformation} > /dev/null
	    sysflag=`echo $?`
	    if [ ${sysflag} -eq 255 ]; then
		    echo ""
		    error "Failed to read header of image ${inputImgB} or initial deformation ${initDeformation}!"
		    echo
		    exit 1
	    elif [ ${sysflag} -eq 0 ]; then
		    echo
		    error "Input initial deformation should be defined in the space of image ${inputImgB}!"
		    echo
		    exit 1
	    fi

	    # check 5-2.2
	    NDim=${sysflag}
	    NDispComponents=`execute --allow_fail -- TransformOperation ${initDeformation} |sed -n 1p |cut -d' ' -f6`
	    if [ ${NDim} == 3 ]&&[ ${NDispComponents} != ${NDim} ]; then
		    echo 
		    error "Please double check the initial deformation field (${initDeformation})! The displacement vector at each voxel should have ${NDim} components (moving in ${NDim}-D space). Right now there are ${NDispComponents} component(s) (according to variable 'dim5' in the header), which is incorrect."
		    echo
    		    exit 1
	    fi

	    initDeformation=`readlink2 ${initDeformation}`
	    initDeformation_basename=`basename ${initDeformation}`
	    initDeformation_path=`realpath ${initDeformation}`
	    initDeformation_path=`dirname ${initDeformation_path}`
	    initDeformation_fullname=${initDeformation_path}/${initDeformation_basename}
	    if [ ! -f ${initDeformation} ]; then
		echo -e "\nError: input initial transformation file ${initDeformation} does not exist. Program exits.\n"
		exit 1
	    fi
    fi
fi


# ----------------------------------------------------------------------------
# check 6: check required input if RAVENS calculation is requested
if [ $RAVENS != 'NULL' ]; then
    RAVENS_basename=`basename ${RAVENS}`
    RAVENS_path=`realpath ${RAVENS}`
    RAVENS_path=`dirname ${RAVENS_path}`
    RAVENS_prefix=`basename ${RAVENS_basename}`

    if [ ! -d ${RAVENS_path} ] || [ -z ${RAVENS_path} ]; then
        echo
        error 'The given directory to store RAVENS maps to does not exist.'
        echo
        exit 1
    fi

    # check 6a. RAVENS calculate requires input of label map.
    if [ $LabelMap == 'NULL' ]; then
        echo
        error "Calculation of RAVENS requires input of label map (-L option) in subject space! And the label map must be in byte datatype."
        echo
        exit 1
    else
        # check 6b. label map should be in the subject space
        execute --allow_fail -- CheckTwoImages ${LabelMap} ${inputImgB} > /dev/null
		sysflag=`echo $?`
        if [ ${sysflag} -eq 255 ]; then
            echo
            error "Failed to read header of label map ${LabelMap} or image ${inputImgB}!"
            echo
            exit 1
        elif [ ${sysflag} -eq 0 ]; then
            echo
            error "Label map ($LabelMap) should be in the same space with subject image ($inputImgB)!"
	    error "This requires these two images having *exactly the same* image size and voxel size."
            echo
            exit 1
        fi

        # check 6c. label values in label map should be given
        if [ ${labelValues} == "99999" ]; then
            echo 
            error "Please specify the label values in the label map for calculating RAVENS map (ie, which labeled tissue/structure in the label map you would like to calculate RAVENS for, eg, -l 50,150,250)."
            echo
            exit 1
        fi

        # till now we are assured that the label map has been input corrected (exist, in byte datatype and in subject space), we can go ahead to calculate RAVENS maps
	LabelMap=`readlink2 ${LabelMap}`
        LabelMap_basename=`basename ${LabelMap}`
        LabelMap_path=`realpath ${LabelMap}`
        LabelMap_path=`dirname ${LabelMap_path}`
        LabelMap_fullname=${LabelMap_path}/${LabelMap_basename}
	if [ ! -f ${LabelMap} ]; then
		echo -e "\nError: input label map ${LabelMap} does not exist. Program exits.\n"
		exit 1
	fi

        if [ ${verbose} -gt 0 ]; then
            echo "Input subject image = ${inputImgB_basename}"
            echo "Input label map = ${LabelMap_basename}"
            echo
            echo "All the inputs for RAVENS calculation are fine."
            echo "Calculated RAVENS maps will be in the template space (same as in ${inputImgA_basename}), and will be saved as SHORT datatype."
            echo
        fi
    fi 
fi


# ----------------------------------------------------------------------------
# check 7: check if the given directory for jacobian exists if user wants to calculate jacobian.
if [ ${Jacobian} != 'NULL' ]; then
    Jacobian_basename=`basename ${Jacobian}`
    Jacobian_path=`realpath ${Jacobian}`
    Jacobian_path=`dirname ${Jacobian_path}`
    Jacobian_fullname=${Jacobian_path}/${Jacobian_basename}

    if [ ! -d ${Jacobian_path} ] || [ -z "${Jacobian_path}" ]; then
        echo
        error 'The given directory to store jacobian determinant maps to does not exist!'
        echo
        exit 1
    fi
fi


# ----------------------------------------------------------------------------
# check 8: check necessary input if warping image using obtained deformation is requested
if [ ${WarpedImage} != 'NULL' ]; then
    if [ ${RAVENS} != 'NULL' ]; then
        error "Cannot calculate RAVENS maps and warp images at the same time as this requires registration in reverse directions:"
        error "calculating RAVENS maps requires registration from template to subject, while warping image indicates the other way around."
        error "We can only do one of these tasks at a time."
        echo
        exit 1
    fi

    WarpedImage_basename=`basename ${WarpedImage}`
    WarpedImage_path=`realpath ${WarpedImage}`
    WarpedImage_path=`dirname ${WarpedImage_path}`
    WarpedImage_fullname=${WarpedImage_path}/${WarpedImage_basename}

    if [ ! -d ${WarpedImage_path} ] || [ -z ${WarpedImage_path} ]; then
        echo
        error "The given directory to store the warped image to (${WarpedImage_path}) does not exist."
        echo
        exit 1
    fi

    # check input image to be warped.
    if [ $LabelMap == 'NULL' ]; then
        echo
        error "Warping an additional image requires specification of image to warp (-L option)!"
        echo
        exit 1
    else
	LabelMap=`readlink2 ${LabelMap}`
        LabelMap_basename=`basename ${LabelMap}`
        LabelMap_path=`realpath ${LabelMap}`
        LabelMap_path=`dirname ${LabelMap_path}`
        LabelMap_fullname=${LabelMap_path}/${LabelMap_basename}
	if [ ! -f ${LabelMap} ]; then
		echo -e "\nError: input label map ${LabelMap} does not exist. Program exits.\n"
		exit 1
	fi

        # check if the label map is in the subject space
        execute --allow_fail -- CheckTwoImages ${LabelMap} ${inputImgA} > /dev/null
		sysflag=`echo $?`
        if [ ${sysflag} -eq 255 ]; then
            echo
            error "Failed to read header of label map ${LabelMap} or image ${inputImgA}!"
            echo
            exit 1
        elif [ ${sysflag} -eq 0 ]; then
            echo
            error "Label map ($LabelMap) must be in the same space with subject image ($inputImgA)!"
	    error "Please double check if these two images have *exactly the same* image size and voxel size."
            echo
            exit 1
        fi

        # check interpolation method when warping image
        if [ ${interpolationWarp} != "1" ] && [ ${interpolationWarp} != "0" ]; then
            error "Interpolation method must be either nearest neighbor (0) or trilinear (1) for warping the image!"
            echo
            exit 1
        fi

        # till now we are assured that the input image to be warped has been input correctly (exist in subject space),
        # we can go ahead to calculate WarpedImage after having obtained the deformation
        if [ ${verbose} -gt 0 ]; then
            echo "Input image to warp = ${WarpedImage_basename}"
            echo "Input image to be warped = ${LabelMap_basename}"
            echo
            echo "Input for warping image is fine."
            echo "The warped image will be in template space (same as in ${inputImgB_basename})."
            echo
        fi
    fi
fi
    

# ----------------------------------------------------------------------------
# check 9: if affine registration is requested ("-a 1" or "-a 2" option), or if there is input affine matrix as an initialization, check if flirt exists
if [ ${affineOrNot} != "0" ]||[ ${initAffineMatrix} != 'NULL' ]; then
    exepath FLIRTCMD flirt
    if [ -z ${FLIRTCMD} ]; then
	error "Could not find FSL's FLIRT command in your PATH! i.e., the command 'which flirt' does not return the path to the flirt executible."
	error "Possible and common reasons are: 1) flirt is not installed in your system; 2) flirt is not added into the system's PATH environment; or 3) flirt is named differently, such as fsl-flirt or FLIRT."
      error "Please install FSL and make sure that the directory to the flirt executable is listed in your PATH environment variable. For a proper installation of FSL, please refer to the FSL documentation such as the one at http://www.fmrib.ox.ac.uk/fsl/fsl/linux.html with installation instructions on Unix."
      exit 1
    fi
fi
if [ ${affineOrNot} != "0" ]&&[ ${affineOrNot} != "1" ]&&[ ${affineOrNot} != "2" ]&&[ ${affineOrNot} != "3" ]&&[ ${affineOrNot} != "4" ]; then
	error "the -a' option must be followed with either 0, 1, 2, 3 or 4. "
	error "please see help (dramms -h). Program exits."
	exit 1
fi


# ----------------------------------------------------------------------------
# check 10: if user didn't specify regularization, determine default based on other user inputs
if [ ${regularizationWeight} == '-1' ]; then  
    #  I. Ordinary version: medium-level aggressive deformation
    regularizationWeight=0.2
    # II. RAVENS version:   use a smoother deformation for calculating RAVENS
    if [ $RAVENS != 'NULL' ]; then
        regularizationWeight=0.3
    fi
    # III. ROI version: use more aggressive deformation for ROI warping
    if [ $WarpedImage != 'NULL' ] && [ $interpolationWarp == "0" ]; then
        regularizationWeight=0.15
    fi
fi
# automatically mapping regularization weighting and label_factor to allow deformations ranging from aggressive to smooth when user input weights varies between [0,1]
if [ ${verbose} -gt 0 ]; then
    echo "Automatically mapping regularization weights and label factor to roughly the range [0,1]"
fi
regularizationWeightMapped=`echo "(0.15*e(3.0*l($regularizationWeight/0.15)))" | bc -l`
if [ ${verbose} -gt 0 ]; then
    echo "Regularization = $regularizationWeightMapped"
    echo "Label factor = $label_factor"
    echo
fi


# ----------------------------------------------------------------------------
# check 11: number of Gabor scales
if [ $numGaborScales -lt 3 ] || [ $numGaborScales -gt 4 ]; then
   error 'The current version only supports the number of Gabor scales to be 3 or 4!'
   error 'Please choose a supported number of Gabor scales.'
   echo 
   exit 1
fi
if [ ${verbose} -gt 0 ]; then
   echo "Number of Gabor scales = $numGaborScales"
   echo
fi

############################################
#
### Summary
#
############################################

echo -------------------------------------------------------------------------------------------
echo "DRAMMS: Deformable image Registration via Attribute Matching and Mutual-Saliency weighting"
echo -------------------------------------------------------------------------------------------
echo
if [ ${verbose} -gt 0 ]; then
    echo
    echo ----------------------------------------
    echo "Registering from"
    echo "  ${inputImgA_basename} (in directory ${inputImgA_path})"
    echo "to"
    echo "  ${inputImgB_basename} (in directory ${inputImgB_path}),"
    echo ''
    echo "Registered image will be"
    echo "  ${outputImgA2B_basename} (in directory ${outputImgA2B_path})"
    echo "and deformation will be "
    echo "  ${deformationFieldA2B_basename} (in directory ${deformationFieldA2B_path})."
    echo ''
    echo "Both registered image and deformation field will be in the same space as ${inputImgB_basename}."
    if [ $RAVENS != 'NULL' ]; then
    echo "RAVENS maps will be in the sampe space as ${inputImgA_basename}."
    fi
    echo ----------------------------------------
    echo
    # echo "Distance between control points = (${distBetweenControlPointsX},${distBetweenControlPointsY},${distBetweenControlPointsZ})"
    echo "Gabor attributes will be computed at $numGaborScales scales and in $numGaborOrientations orientations"
    echo "During discrete optimization, number of samples: ${numDiscreteSamples}"
    echo "Manipulation method of control points:           ${manipulationMethod}"
    echo "Regularization weight:                           ${regularizationWeight}"
    echo "Input mask:                                      ${inputmask}"
    echo "Temporary working directory:                     ${tmpdir}"
    echo "Temporary attribute directory:                   ${attributeDIR}"
    echo "Intermediate results directory:                  ${intermediateDIR}"
    echo
fi


##############################
#
### Registration
#
# Step 1:  (preprocessing for attribute extraction) smooth and convert to byte
# Step 2:  (preprocessing for attribute extraction) match histogram if necessary 
# Step 3:  (optional) affine registration
# Step 4a: (optional) remove affine component from initial deformation
# Step 4b: (optional) ensure that initial deformation is diffeomorphic
# Step 5a: generate multi-resolution images
# Step 5b: extract Gabor attribute images
# Step 6:  non-rigid registration
# Step 7:  combine affine and deformable transformations
# Step 8:  warp template image
#
##############################

# ----------------------------------------------------------------------------
# change working directory
cd ${intermediateDIR}
sysflag=`echo $?`
[ ${sysflag} -eq 0 ] || {
    echo
    error "Failed to change to directory ${intermediateDIR}!"
    echo
    exit 1
}
[ ${verbose} -gt 0 ] && {
    echo
    echo "Changed to directory ${intermediateDIR}"
    echo
}


# ----------------------------------------------------------------------------
echo "Step 1:   Convert images to byte datatype..."
run ConvertImage -s -e --reset-scaling -t uchar -m 0 -M 255 ${inputImgA_fullname} A_byte.nii.gz
run ConvertImage -s -S --reset-scaling -t uchar -m 0 -M 255 ${inputImgA_fullname} A_byte_nothresholding.nii.gz
run ConvertImage -s -e --reset-scaling -t uchar -m 0 -M 255 ${inputImgB_fullname} B_byte.nii.gz
run ConvertImage -s -S --reset-scaling -t uchar -m 0 -M 255 ${inputImgB_fullname} B_byte_nothresholding.nii.gz


# ----------------------------------------------------------------------------
echo "Step 2:   Match histograms if necessary..."
#          This program is more "intellegent" than simply matching histogram of image A to image B
#          It checks histograms of both images, automatically determines 1) whether to match their histograms
#          and 2) if necessary, match histogram of which image to which image.
run cp A_byte.nii.gz A_byte0.nii.gz
run cp B_byte.nii.gz B_byte0.nii.gz
if [ ${matchHistogramFlag} -eq 1 ]; then
	run MatchHistograms A_byte.nii.gz B_byte.nii.gz -M
else
	run MatchHistograms A_byte.nii.gz B_byte.nii.gz
fi

	# to determine whether to keep the byte images before or after histogram matching
	if [ ${matchHistogramFlag} -eq 0 ]; then
		# cc*mi before histogram matching
		cc=`execute CalculateImageSimilarity -C A_byte0.nii.gz B_byte0.nii.gz`
		sysflag=`echo $?`
        [ ${sysflag} -eq 0 ] || { error "Failed to compute cross-correlation of A_byte0.nii.gz and B_byte0.nii.gz!"; exit 1; }
        mi=`execute CalculateImageSimilarity -N A_byte0.nii.gz B_byte0.nii.gz`
		sysflag=`echo $?`
        [ ${sysflag} -eq 0 ] || { error "Failed to compute normalized mutual information of A_byte0.nii.gz and B_byte0.nii.gz!"; exit 1; }

        cc=`echo -e "${cc}" | grep CC              | cut -d'=' -f2`
        cc=`echo ${cc} | awk '{ print $1 }' | tr -d - ` # we shall only care about the absolute value of cc
        mi=`echo -e "${mi}" | grep MI_normalized | cut -d'=' -f2`

        mi_cc0=`echo "${cc}*${mi}" | bc -l`
		sysflag=`echo $?`
        if [ ${sysflag} -ne 0 ]; then
            error "Failed to compute product of cross-correlation and mutual information!" 1>&2
            exit 1
        fi

		# cc*mi after histogram matching
		cc=`execute CalculateImageSimilarity -C A_byte.nii.gz B_byte.nii.gz`
		sysflag=`echo $?`
        [ ${sysflag} -eq 0 ] || { error "Failed to compute cross-correlation of A_byte.nii.gz and B_byte.nii.gz!"; exit 1; }
        mi=`execute CalculateImageSimilarity -N A_byte.nii.gz B_byte.nii.gz`
		sysflag=`echo $?`
        [ ${sysflag} -eq 0 ] || { error "Failed to compute normalized mutual information of A_byte.nii.gz and B_byte.nii.gz!"; exit 1; }

        cc=`echo -e "${cc}" | grep CC              | cut -d'=' -f2`
        cc=`echo ${cc} | awk '{ print $1 }' | tr -d - ` # we shall only care about the absolute value of cc
        mi=`echo -e "${mi}" | grep MI_normalized | cut -d'=' -f2`

        mi_cc=`echo "${cc}*${mi}" | bc -l`
		sysflag=`echo $?`
        if [ ${sysflag} -ne 0 ]; then
            error "Failed to compute product of cross-correlation and mutual information!" 1>&2
            exit 1
        fi
		
		# compare and make decision
		before_vs_after=`echo ${mi_cc0} '>' ${mi_cc} | bc -l`
		sysflag=`echo $?`
        if [ ${sysflag} -ne 0 ]; then
            error "Comparison of image similarity before and after histogram matching failed!" 1>&2;
            exit 1;
		else
			if [ ${verbose} -gt 0 ]; then
				echo "Compare image similarity before and after histogram matching."
				echo "before: cc*mi = ${mi_cc0}"
				echo "after : cc*mi = ${mi_cc}"
			fi
        fi

        if [ "${before_vs_after}" -eq 1 ]; then
			if [ ${verbose} -gt 0 ]; then
				echo "We decided to keep byte images before histogram matching, as histomatch reduced image similarity."
				echo ""
			fi
            run mv A_byte0.nii.gz A_byte.nii.gz
            run mv B_byte0.nii.gz B_byte.nii.gz
		else
			if [ ${verbose} -gt 0 ]; then
				echo "We decided to keep byte images after histogram matching, as histomatch increased image similarity."
				echo ""
			fi
			run rm A_byte0.nii.gz
			run rm B_byte0.nii.gz
        fi
	fi
	
	
# ----------------------------------------------------------------------------
# get dimensionality of input image
image_info=`execute --allow_fail -- CheckTwoImages ${inputImgA_fullname} ${inputImgB_fullname}`
sysflag=`echo $?`
if [ ${sysflag} -eq 255 ]; then
    echo
    error "Failed to read header of image ${inputImgA} or ${inputImgB}!"
    echo
    exit 1
fi
if [ ${sysflag} -eq 0 ]; then
	inputImageShareImageVoxelSize=0;
	image_info=`execute --allow_fail -- CheckTwoImages ${inputImgB_fullname} ${inputImgB_fullname}`
	sysflag=`echo $?`
else
	inputImageShareImageVoxelSize=1; 
fi
# get dimension and image size of the target image.
number_of_dimensions=${sysflag}
image_size=`echo ${image_info} | grep 'Image size' | sed 's/Image size: (//;s/)//'`
xSize=`echo ${image_size} | cut -d, -f 1| tr -d ' '`
ySize=`echo ${image_size} | cut -d, -f 2| tr -d ' '`
zSize=`echo ${image_size} | cut -d, -f 3 |cut -d' ' -f2| tr -d ' '`

# check if ${xSize}, ${ySize} and ${zSize} are purely numerical, othrewise quit and report error
xSize_numerical=`echo ${xSize} | grep "^-\?[0-9]*$"`
ySize_numerical=`echo ${ySize} | grep "^-\?[0-9]*$"`
zSize_numerical=`echo ${zSize} | grep "^-\?[0-9]*$"`
if [ "${xSize}" != "${xSize_numerical}" ] || [ "${ySize}" != "${ySize_numerical}" ] || [ "${zSize}" != "${zSize_numerical}" ]; then
	echo
	error "The image size (${xSize}, ${ySize}, ${zSize}) is non-numerical. Program quits here. Please double check input image headers."
	exit 1
fi
xzratio=`echo "${xSize}/${zSize}" | bc -l`
yzratio=`echo "${ySize}/${zSize}" | bc -l`
		

# added 09/04/2016, also get dimension and image size of source image, to detemrine wether to run flirt registrations using 2D_nosearch
source_image_info=`execute --allow_fail -- CheckTwoImages ${inputImgA_fullname} ${inputImgA_fullname}`
source_image_size=`echo ${source_image_info} | grep 'Image size' | sed 's/Image size: (//;s/)//'`
source_xSize=`echo ${source_image_size} | cut -d, -f 1| tr -d ' '`
source_ySize=`echo ${source_image_size} | cut -d, -f 2| tr -d ' '`
source_zSize=`echo ${source_image_size} | cut -d, -f 3 |cut -d' ' -f2| tr -d ' '`

# check if ${source_xSize}, ${source_ySize} and ${source_zSize} are purely numerical, othrewise quit and report error
source_xSize_numerical=`echo ${source_xSize} | grep "^-\?[0-9]*$"`
source_ySize_numerical=`echo ${source_ySize} | grep "^-\?[0-9]*$"`
source_zSize_numerical=`echo ${source_zSize} | grep "^-\?[0-9]*$"`
if [ "${source_xSize}" != "${source_xSize_numerical}" ] || [ "${source_ySize}" != "${source_ySize_numerical}" ] || [ "${source_zSize}" != "${source_zSize_numerical}" ]; then
        echo
        error "The image size (${source_xSize}, ${source_ySize}, ${source_zSize}) is non-numerical. Program quits here. Please double check input image headers."
        exit 1
fi
source_xzratio=`echo "${source_xSize}/${source_zSize}" | bc -l`
source_yzratio=`echo "${source_ySize}/${source_zSize}" | bc -l`

		
# ----------------------------------------------------------------------------
chosencc=1 # initialize cc (correlation coefficient between two images)
if  [ ${affineOrNot} -eq 0 ]; then # user chooses not to run affine, assuming the input images have already been affinely aligned.
	if [ ${initAffineMatrix} == 'NULL' ]; then # no initial affine matrix input
		if [ ${inputImageShareImageVoxelSize} -eq 1 ]; then
			echo "Step 3:   Skip affine registration per the user's request (because -a option is set 0). The two input images are assumed to be already affinely aligned."
			ImgA2BAffine=A_byte.nii.gz
		else
			echo "Step 3:  Skip affine registration per the user's request (because -a option is set 0)."
			error "However, two input images do not share image and/or voxel size. Please double check if they are indeed affinely-aligned, or use '-a 1' to turn on affine registration."
			echo ""
			exit 1
		fi
	else # there is an initial affine matrix input
		echo "Step 3: affine registration. There is an input of an initial affine matrix (${initAffineMatrix}). DRAMMS takes the initial affine matrix and will not re-do the affine."
		\cp ${initAffineMatrix_fullname} A2B_affine.mat
		MatA2BAffine=A2B_affine.mat
		ImgA2BAffine=A2B_affine.nii.gz
		run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${ImgA2BAffine} -init ${MatA2BAffine} -applyxfm
		echo ""
		echo "the input initial affine matrix is"
		cat ${MatA2BAffine} | sed 's/^/          /'
	fi

else  # run affine/rigid registration within dramms
    if [ ${affineOrNot} == "1" ]||[ ${affineOrNot} == "2" ]; then # affine
	echo "Step 3:   Affine registration of images by FSL's flirt tool (may take several minutes)..."
	dof=12
    else # rigid
	echo "Step 3:   Rigid  registration of images by FSL's flirt tool (may take several minutes)..."
	dof=6
    fi

    [ ${verbose} -gt 0 ] && echo

    ImgA2BAffine=A2B_affine.nii.gz
    MatA2BAffine=A2B_affine.mat

	# calculate the affine transformation matrix from preprocessed byte images.
	simset="normmi180 corratio180"
	trialind=1
	Tried2Dnosearch=0
	max_mi_cc_inter=0
	max_mi_cc_full=0
    while [ ${trialind} -le 3 ]; do
    	if [ ${trialind} == 1 ]; then
		if [ ! -f ${intermediateDIR}/A2B_affine_normmi180.nii.gz ]; then 
			[ ${verbose} -gt 0 ] && echo -e "\nTry using normmi as similarity metric for affine registration, search range [-180, 180]\n"
	    		run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${intermediateDIR}/A2B_affine_normmi180.nii.gz -omat ${intermediateDIR}/A2B_affine_normmi180.mat -cost normmi -searchcost normmi -searchrx -180 180 -searchry -180 180 -searchrz -180 180 -dof ${dof} -datatype char &
		fi
		if [ ! -f ${intermediateDIR}/A2B_affine_corratio180.nii.gz ]; then
	    		[ ${verbose} -gt 0 ] && echo -e "\nTry using corratio as similarity metric for affine registration, search range [-180, 180]\n"
    			run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${intermediateDIR}/A2B_affine_corratio180.nii.gz -omat ${intermediateDIR}/A2B_affine_corratio180.mat -cost corratio -searchcost corratio -searchrx -180 180 -searchry -180 180 -searchrz -180 180 -dof ${dof} -datatype char &
		fi
	fi
	if ([ ${affineOrNot} -lt 3 ]&&[ ${trialind} == 2 ])||([ ${affineOrNot} -gt 2 ]&&[ ${trialind} == 1 ]); then	# if affine, do 45 search only in the second round; if rigid, do 45 search in the first round
		simset="${simset} normmi45 corratio45"
		if [ ! -f ${intermediateDIR}/A2B_affine_normmi45.nii.gz ]; then
			[ ${verbose} -gt 0 ] && echo -e "\nTry using normmi as similarity metric for affine registration, search range [-45, 45]\n"
    			run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${intermediateDIR}/A2B_affine_normmi45.nii.gz -omat ${intermediateDIR}/A2B_affine_normmi45.mat -cost normmi -searchcost normmi -searchrx -45 45 -searchry -45 45 -searchrz -45 45 -coarsesearch 15 -finesearch 5 -dof ${dof} -datatype char &
		fi
		if [ ! -f ${intermediateDIR}/A2B_affine_corratio45.nii.gz ]; then
	    		[ ${verbose} -gt 0 ] && echo -e "\nTry using corratio as similarity metric for affine registration, search range [-45, 45]\n"
    			run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${intermediateDIR}/A2B_affine_corratio45.nii.gz -omat ${intermediateDIR}/A2B_affine_corratio45.mat -cost corratio -searchcost corratio -searchrx -45 45 -searchry -45 45 -searchrz -45 45 -coarsesearch 15 -finesearch 5 -dof ${dof} -datatype char &
		fi
	fi
	if (([ `echo ${xzratio} '>=' 4 | bc -l` -eq 1 ]||[ `echo ${yzratio} '>=' 4 | bc -l` -eq 1 ]||[ `echo ${source_xzratio} '>=' 4 | bc -l` -eq 1 ]||[ `echo ${source_yzratio} '>=' 4 | bc -l` -eq 1 ])&&[ "${trialind}" == 1 ])||([ "${trialind}" == 3 ]&&[ "${Tried2Dnosearch}" == 0 ]); then  # in case of large z-thickness, also try 2D_nosearch affine registration; or, in case the first 2 trials fail, try 2D_nosearch in the third trial
		simset="${simset} normmi_2D_nosearch corratio_2D_nosearch"
		Tried2Dnosearch=1
		if [ ! -f ${intermediateDIR}/A2B_affine_normmi_2D_nosearch.nii.gz ]; then
			[ ${verbose} -gt 0 ] && echo -e "\nTry using normmi as similarity metric, -nosearch -2D, for affine registration, default search range [-90, 90]\n"
			run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${intermediateDIR}/A2B_affine_normmi_2D_nosearch.nii.gz -omat ${intermediateDIR}/A2B_affine_normmi_2D_nosearch.mat -cost normmi -searchcost normmi -2D -nosearch -datatype char &
		fi
		if [ ! -f ${intermediateDIR}/A2B_affine_corratio_2D_nosearch.nii.gz ]; then
			[ ${verbose} -gt 0 ] && echo -e "\nTry using corratio as similarity metric, -nosearch -2D, for affine registration, default search range [-90, 90]\n"
			run ${FLIRTCMD} -in A_byte.nii.gz -ref B_byte.nii.gz -out ${intermediateDIR}/A2B_affine_corratio_2D_nosearch.nii.gz -omat ${intermediateDIR}/A2B_affine_corratio_2D_nosearch.mat -cost corratio -searchcost corratio -2D -nosearch -datatype char &
		fi
	fi
    	# wait for background jobs to finish
    	wait
        # added on 5/13/2015, we noticed that the out of FOV interpolation is not strictly 0 using flirt registration when register a small FOV (e.g., partial brain) to a big FOV (e.g., full brain). therefore, we use dramms-warp to transform the image again to get out of FOV regions to 0 (what they should be).
        for xfm in *.mat; do
                execute ApplyTransform A_byte.nii.gz ${xfm} ${xfm%.mat}.nii.gz -t B_byte.nii.gz
        done
    	# when all above 4 affine tries have finished, pick the best one with highest mi * abs(cc)
	# modified on 09/04/2016, not only look at cc and mi in the intersection of images (v1.4.3, in preparation some images have big FOV mismatch), but also look at cc and mi in the whole image, to avoid the extreme case that when a registered image is shrunk to a point or small patch, the cc and mi in the intersection regions are very high but the results are undesirable.
    	[ ${verbose} -gt 0 ] && echo "Selecting best affine registration results"
    	for sim in ${simset}; do
		tmpaffineimg="${intermediateDIR}/A2B_affine_${sim}.nii.gz"
		if [ -f ${tmpaffineimg} ]; then # modified on 11/8/2014, based on Jimit's report of one failed flirt affine registration. Now we allow flirt to fail in very very rare cases, and proceed with the images that flirt successfully generated
	        	cc_inter=`execute CalculateImageSimilarity -C -I ${tmpaffineimg} B_byte.nii.gz`	
			cc_full=`execute CalculateImageSimilarity -C ${tmpaffineimg} B_byte.nii.gz`
			sysflag=`echo $?`
	        	[ ${sysflag} -eq 0 ] || { error "Failed to compute cross-correlation of A2B_affine_${sim}.nii.gz and B_byte.nii.gz!"; exit 1; }
                        if [ ${affineOrNot} -gt 2 ]; then
                                mi_inter=`execute CalculateImageSimilarity -M -I ${tmpaffineimg} B_byte.nii.gz`
				mi_full=`execute CalculateImageSimilarity -M ${tmpaffineimg} B_byte.nii.gz`
                        else
                                mi_inter=`execute CalculateImageSimilarity -N -I ${tmpaffineimg} B_byte.nii.gz`
				mi_full=`execute CalculateImageSimilarity -N ${tmpaffineimg} B_byte.nii.gz`
                        fi
			sysflag=`echo $?`
	        	[ ${sysflag} -eq 0 ] || { error "Failed to compute normalized mutual information of A2B_affine_${sim}.nii.gz and B_byte.nii.gz!"; exit 1; }

	        	cc_inter=`echo -e "${cc_inter}" | grep CC | cut -d'=' -f2`
        		cc_inter=`echo ${cc_inter} | awk '{ print $1 }' | tr -d - ` # we shall only care about the absolute value of cc
        		mi_inter=`echo -e "${mi_inter}" | grep MI | cut -d'=' -f2 | awk '{ print $1 }' | tr -d -`

			cc_full=`echo -e "${cc_full}" | grep CC | cut -d'=' -f2`
                        cc_full=`echo ${cc_full} | awk '{ print $1 }' | tr -d - ` # we shall only care about the absolute value of cc
                        mi_full=`echo -e "${mi_full}" | grep MI | cut -d'=' -f2 | awk '{ print $1 }'| tr -d -`


	        	mi_cc_inter=`echo "${cc_inter}*${mi_inter}" | bc -l`
			mi_cc_full=`echo "${cc_full}*${mi_full}" | bc -l`
			sysflag=`echo $?`
        		if [ ${sysflag} -ne 0 ]; then
            			error "Failed to compute product of cross-correlation and mutual information!" 1>&2
	            		exit 1
        		fi
                        FOVpenalty=`calculatepenalty ${intermediateDIR}/A2B_affine_${sim}.mat`
                        mi_cc_inter=`echo "${mi_cc_inter} - 1.2*${FOVpenalty}" | bc -l`
                        #sysflag=`echo $?`
                        #[ ${sysflag} -ne 0 ] || { error "Failed to compute penalty into the similarity cost function!"; exit 1; }

        		if [ ${verbose} -gt 0 ]; then
            			echo
            			echo "when sim=${sim}: mi_inter=${mi_inter}, cc_inter=${cc_inter}, mi_inter*cc_inter=${mi_cc_inter}; mi_full=${mi_full}, cc_full=${cc_full}, mi_full*cc_full=${mi_cc_full}"
	        	fi
		
			# the following rule was used till 09/04/2016
        		#mi_cc_vs_max_mi_cc_inter=`echo ${mi_cc_inter} '>' ${max_mi_cc_inter} | bc -l`
			#sysflag=`echo $?`
	        	#if [ ${sysflag} -ne 0 ]; then
        	    	#	error "Comparison of image similarity to currently maximum similarity failed!" 1>&2;
            		#	exit 1;
	        	#fi
			#
        		#if [ "${mi_cc_vs_max_mi_cc_inter}" -eq 1 ]; then
            		#	run cp ${tmpaffineimg} ${ImgA2BAffine}
            		#	run cp ${tmpaffineimg%.nii.gz}.mat    ${MatA2BAffine}
	            	#	max_mi_cc_inter=${mi_cc_inter}
			#	chosencc=${cc_inter}
        		#fi

			# new rule on 09/04/2016, look at both inter_FOV and full image similarities, prefer to look at inter_FOV, as long as full image similarity is not too low.
			win_by_inter=0;
			win_by_full=0;

			if [ `echo "${mi_cc_inter} > ${max_mi_cc_inter}" |bc -l` == 1 ]&&[ `echo "${mi_cc_full} > 0.6 * ${max_mi_cc_full}" |bc -l` == 1 ]; then 
				win_by_inter=1
			fi
			if [ `echo "${mi_cc_inter} > 0.6 * ${max_mi_cc_inter}" |bc -l` == 1 ]&&[ `echo "${mi_cc_full} > 2.5 * ${max_mi_cc_full}" |bc -l` == 1 ]; then
                                win_by_full=1
                        fi
			if [ "${win_by_inter}" == 1 ]||[ "${win_by_full}" == 1 ]; then
				run cp ${tmpaffineimg} ${ImgA2BAffine}
                                run cp ${tmpaffineimg%.nii.gz}.mat    ${MatA2BAffine}
                                max_mi_cc_inter=${mi_cc_inter}
				max_mi_cc_full=${mi_cc_full}
                                chosencc=$( (( `echo ${cc_inter} '<=' ${cc_full} |bc -l`)) && echo "${cc_inter}" || echo "${cc_full}" )
			fi
		fi
    	done
    	# check if affine registration results make sense. We have done mutualinfo and corratio with search range [-180,180], if the maximum cc*mi is still <0.1, we need to search again with a narrower search range [-45,45]
    	if [ `echo ${max_mi_cc_full} '<' 0.1 | bc -l` -eq 1 ]||[ `echo ${max_mi_cc_inter} '<' 0.1 | bc -l` -eq 1 ]; then
		if [ ${affineOrNot} -lt 3 ]; then # affine
			trialind=$(( ${trialind} + 1 ))
		elif [ ${affineOrNot} -gt 2 ]; then # rigid
			trialind=$(( ${trialind} + 2 ))
		fi
	else
		trialind=4;
    	fi
    done
    # check if affine registration finishes successfully
	sysflag=`echo $?`
    if [ ${sysflag} -ne 0 ] || [ ! -f ${ImgA2BAffine} ] || [ ! -f ${MatA2BAffine} ]; then
        echo
        error "Affine registration failed! No affine matrix was saved."
        echo
        exit 1
    else
        if [ ${verbose} -gt 0 ]; then
            echo
            echo "          Affine registration finished successfully."
            echo
            echo "          The computed affine transformation is:"
            cat ${MatA2BAffine} | sed 's/^/          /'
            echo
            echo
        fi
    fi
fi


if [ ${verbose} -gt 1 ]; then
    echo
    echo "Number of dimensions = ${number_of_dimensions}"
    echo "Image size = (${xSize}, ${ySize}, ${zSize})"
    echo "Affine registered image = ${intermediateDIR}/${ImgA2BAffine}"
    echo
fi

if [ ${affineOrNot} == "2" ]||[ ${affineOrNot} == "4" ]; then # exit right after affine, no deformable needed
	run cp ${MatA2BAffine} ${deformationFieldA2B_fullname%.mat}.mat
	#run ${FLIRTCMD} -in ${inputImgA_fullname} -ref ${inputImgB_fullname} -out ${outputImgA2B_fullname%.nii.gz}.nii.gz -init ${MatA2BAffine} -applyxfm
	run ApplyTransform ${inputImgA_fullname} ${MatA2BAffine} ${outputImgA2B_fullname%.nii.gz}.nii.gz -t ${inputImgB_fullname}
	echo ""
	echo "This user has specified to do affine or rigid registration only, and no deformable components involved (throught '-a 2' or '-a 4' option)."
	echo "The output affinely/rigidly-registered image is ${outputImgA2B_fullname%.nii.gz}.nii.gz"
	echo "The output affine/rigid matrix is ${deformationFieldA2B_fullname%.mat}.mat"
	echo ""
	echo "Program exits successfully."
	echo ""
	exit 0
fi


# if the input mask is in the source space, put it into the target space.
if [ ${inputmasks} != 'NULL' ]; then
	if [ ${affineOrNot} == "0" ]&&[ ${initAffineMatrix} == 'NULL' ]; then # if no affine matrix exits
		inputmask=${inputmasks}
		inputmask_fullname=${inputmasks_fullname}
	else # if there is an affine matrix (either calculated or initialized)
		inputmask=maskintargetspace.nii.gz
		inputmask_fullname=${intermediateDIR}/${inputmask}
		run ${FLIRTCMD} -in ${inputmasks_fullname} -ref B_byte.nii.gz -out ${inputmask_fullname} -init ${MatA2BAffine} -applyxfm -interp nearestneighbour
		if [ ! -f ${inputmask_fullname} ]; then
			echo "failed to affinely transform the ${inputmasks} into the target space."
			echo "program exits."
			exit 1
		fi
	fi
fi


# ----------------------------------------------------------------------------
# smooth initial deformation field and remove affine component
if [ ${initDeformation} != 'NULL' ]; then
    if [ ${affineOrNot} != 0 ]; then 
        echo "Step 4a:  Remove affine component from initial deformation..."
        initDeformation_DeformableOnly=initdef.nii.gz
        # first, remove the affine component in the input initial deformation, leaving only the deformable part for initilization
		run CombineTransforms -s -f A_byte.nii.gz -t B_byte.nii.gz ${initDeformation_fullname} ${MatA2BAffine} ${initDeformation_DeformableOnly}
    else
        echo "Step 4a:  Skip removal of affine component from initial deformation field as affine registration was skipped."
        initDeformation_DeformableOnly=${initDeformation_fullname}
    fi

    # then, smooth the initial deformable part if it has negative jacobian determinants
    echo "Step 4b:  Make initial deformation diffeomorphic if necessary..."
    for i in 1 2; do # smooth twice at most
	    	if [ -s A2B_affine.nii.gz ]; then
        		msg=`execute CalculateJacobianMap ${initDeformation_DeformableOnly} jacobian.nii.gz -f A2B_affine.nii.gz -t B_byte.nii.gz`
		else
			msg=`execute CalculateJacobianMap ${initDeformation_DeformableOnly} jacobian.nii.gz -f A_byte.nii.gz -t B_byte.nii.gz`
		fi

		sysflag=`echo $?`
		[ ${sysflag} -eq 0 ] || { error "Failed to calculate minimum Jacobian of ${initDeformation_DeformableOnly}!"; exit 1; }
        minJac=`echo ${msg} | cut -d "=" -f5 |cut -d' ' -f1`
		if [ ${verbose} -gt 0 ]; then echo minJac=$minJac; fi
		run rm -f jacobian.nii.gz
        if [ `echo ${minJac} | cut -c1` == '-' ]; then  # negative jacobian exists
            if [ ${verbose} -gt 0 ]; then
                echo "Initial deformation is not diffeomorphic: min Jacobian = ${minJac}"
                echo "Smoothing, round $i..."
            fi
			# determine smoothing kernels adaptive to image size
			imageSizeX=`echo ${msg} |cut -d'(' -f2 |cut -d')' -f1 |cut -d',' -f1`
			imageSizeY=`echo ${msg} |cut -d'(' -f2 |cut -d')' -f1 |cut -d',' -f2`
			imageSizeZ=`echo ${msg} |cut -d'(' -f2 |cut -d')' -f1 |cut -d',' -f3`
			if [ ${imageSizeX} -gt ${imageSizeY} ]; then
				smoothingSizeXY=$(( (${imageSizeX}+25)/50 ))
			else
				smoothingSizeXY=$(( (${imageSizeY}+25)/50 ))
			fi
			if [ ${smoothingSizeXY} -lt 3 ]; then
				smoothingSizeXY=3
			fi
			if [ $(( ${smoothingSizeXY}%2 )) -eq 0 ]; then
				smoothingSizeXY=$(( ${smoothingSizeXY}+1 ))
			fi
			smoothingHalfSizeXY=$(( (${smoothingSizeXY}-1)/2 ))
            smoothingSizeZ=$(( (${imageSizeZ}+30)/60 ))
			if [ ${smoothingSizeZ} -lt 1 ]; then
				smoothingSizeZ=1
			fi
			if [ $(( ${smoothingSizeZ}%2 )) -eq 0 ]; then
				smoothingSizeZ=$(( ${smoothingSizeZ}+1 ))
			fi
			smoothingHalfSizeZ=$(( (${smoothingSizeZ}-1)/2 ))
            if [ `echo ${minJac} | cut -c2` == '0' ]; then
                smoothingKernelXY=`echo "scale=2; ${smoothingSizeXY}*0.5" | bc`
            else
                smoothingKernelXY=`echo "scale=2; ${smoothingSizeXY}*0.5*${minJac}" | bc`
            fi
            if [ `echo ${minJac} | cut -c2` == '0' ]; then
                smoothingKernelZ=`echo "scale=2; ${smoothingSizeZ}*0.5" | bc`
            else
                smoothingKernelZ=`echo "scale=2; ${smoothingSizeZ}*0.5*${minJac}" | bc`
            fi
			# smooth deformation (twice)
            run ImageOperation \
                    -s ${smoothingHalfSizeXY},${smoothingHalfSizeZ},${smoothingKernelXY},${smoothingKernelZ} \
                    -s ${smoothingHalfSizeXY},${smoothingHalfSizeZ},${smoothingKernelXY},${smoothingKernelZ} \
                    ${initDeformation_DeformableOnly} initdef_smooth.nii.gz
            run mv -f initdef_smooth.nii.gz initdef.nii.gz
            initDeformation_DeformableOnly=initdef.nii.gz
        else 
            break
        fi
    done
    # after this, we are going to use ${initDeformation_DeformableOnly} to
    # initialize the deformation in the following Deform3D program
fi
if [ ${initAffineMatrix} != 'NULL' ]; then
	echo "Step 4: the previous step considered an initial affine matrix. we don't have an initial deformation to consider in this step."
fi
if [ ${initTransformation} == 'NULL' ]; then
    echo "Step 4:   Skip preprocessing of the initial transformation as none was specified."
fi



# ----------------------------------------------------------------------------
# change working directory
cd ${attributeDIR}
sysflag=`echo $?`
[ ${sysflag} -eq 0 ] || {
    echo
    error "Failed to change to directory ${attributeDIR}!"
    echo
    exit 1
}
[ ${verbose} -gt 0 ] && {
    echo
    echo "Changed to directory ${attributeDIR}"
    echo
}


# ----------------------------------------------------------------------------
echo "Step 5a:  Generate multi-resolution images for the extraction of Gabor attributes..."

# determine the number of image resolutions/levels
if [ ${xSize} -gt 4 ]&&[ ${ySize} -gt 4 ]&&[ ${zSize} -gt 4 ]; then
	numLevels=3;
elif [ ${xSize} -gt 4 ]&&[ ${ySize} -gt 4 ]&&[ ${zSize} -eq 1 ]; then
	numLevels=3;
else 
	numLevels=2;
fi

# image in level 1 (highest resolution)
run cp -f ${intermediateDIR}/${ImgA2BAffine} A2B_affine_level1.nii.gz
# determine which image B version to use (B_byte.nii.gz versus B_byte_nothresholding.nii.gz) --- choose a B version that is more similar with A2B_affine.nii.gz
cc1=`execute CalculateImageSimilarity -C ${intermediateDIR}/${ImgA2BAffine} ${intermediateDIR}/B_byte.nii.gz |grep CC | awk '{ print $1 }' | tr -d -`
cc2=`execute CalculateImageSimilarity -C ${intermediateDIR}/${ImgA2BAffine} ${intermediateDIR}/B_byte_nothresholding.nii.gz |grep CC | awk '{ print $1 }' | tr -d - `
if [ "`echo ${cc1} '>' 0.8*${cc2} | bc -l`" -eq 1 ]; then
	run cp -f ${intermediateDIR}/B_byte.nii.gz   B_level1.nii.gz
else
	run cp -f ${intermediateDIR}/B_byte_nothresholding.nii.gz   B_level1.nii.gz
fi

# images in level 2 (mid-resolution)
run ImageOperation -s auto -r 2 A2B_affine_level1.nii.gz A2B_affine_level2.nii.gz
run ImageOperation -s auto -r 2 B_level1.nii.gz          B_level2.nii.gz

# images in level 3 (low resolution)
if [ ${numLevels} -eq 3 ]; then
	run ImageOperation -s auto -r 4 A2B_affine_level1.nii.gz A2B_affine_level3.nii.gz
	run ImageOperation -s auto -r 4 B_level1.nii.gz          B_level3.nii.gz
fi


# ----------------------------------------------------------------------------
# extract Gabor features - 2D case
echo "Step 5b:  Extract Gabor attributes for deformable registration..."
if [ ${number_of_dimensions} == "2" ]; then

    # parameters
    if [ $numGaborScales -eq 4 ]; then
        ul_level1=0.05
        uh_level1=0.8
        ul_level2=0.075
        uh_level2=1.2
        ul_level3=0.08
        uh_level3=1.28
        ul_level4=0.1
        uh_level4=1.6
    fi
    if [ $numGaborScales -eq 3 ]; then
        ul_level1=0.05
        uh_level1=0.4
        ul_level2=0.075
        uh_level2=0.6
        ul_level3=0.1
        uh_level3=0.8
    fi

    # in level 1
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level1,$uh_level1 -i$foregroundThre A2B_affine_level1.nii.gz A2B_affine_level1 &
    run CalculateGaborTextures -s1 -o1 -u$ul_level1,$uh_level1 -i12 -M ${intermediateDIR}/B_byte_nothresholding.nii.gz B_level1 # to get a mask B_level1_mask.nii.gz
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level1,$uh_level1 -i$foregroundThre B_level1.nii.gz B_level1 &
    # in level 2
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level2,$uh_level2 -i$foregroundThre A2B_affine_level2.nii.gz A2B_affine_level2 &
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level2,$uh_level2 -i$foregroundThre B_level2.nii.gz B_level2 &
    # in level 3
	if [ ${numLevels} -eq 3 ]; then
		run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level3,$uh_level3 -i$foregroundThre A2B_affine_level3.nii.gz A2B_affine_level3 &
		run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level3,$uh_level3 -i$foregroundThre B_level3.nii.gz B_level3 &
	fi
	
    wait

    # generate list files
    i=1
    while [ $i -le ${numLevels} ]; do
        run GenerateGaborListFile -s$numGaborScales -o$numGaborOrientations -H A2B_affine_level$i Gabor_A_level$i.lst
        run GenerateGaborListFile -s$numGaborScales -o$numGaborOrientations -H B_level$i Gabor_B_level$i.lst
        i=$(( $i + 1 ))
    done

# ----------------------------------------------------------------------------
# extract Gabor features - 3D case
else

    # parameters
    if [ $numGaborScales -eq 4 ]; then
        ul_level1=0.05
        uh_level1=0.8
        ul_level2=0.075
        uh_level2=1.2
        ul_level3=0.08
        uh_level3=1.28
        ul_level4=0.1
        uh_level4=1.6
    fi
    if [ $numGaborScales -eq 3 ] && [ $xSize -gt 160 ] && [ $ySize -gt 160 ]; then
        ul_level1=0.1 
        uh_level1=1.6
        if [ $xSize -lt $ySize ]&&[ $xSize -lt 256 ]; then
            uh_level1=`echo "scale=2; 1.6-(1.0-$xSize/256.0)*1.4" | bc`
        elif [ $ySize -lt 256 ]; then
            uh_level1=`echo "scale=2; 1.6-(1.0-$ySize/256.0)*1.4" | bc`
        fi     		
        ul_level2=0.2
        uh_level2=3.2
        ul_level3=0.8
        uh_level3=6.4
    else
        ul_level1=0.15
        uh_level1=1.0
        ul_level2=0.2
        uh_level2=1.6
        ul_level3=1.0
        uh_level3=4.0
    fi

    # in level 1
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level1,$uh_level1 -i$foregroundThre -x1 A2B_affine_level1.nii.gz A2B_affine_level1
	run CalculateGaborTextures -s1 -o1 -u$ul_level1,$uh_level1 -i12 -x1 -M ${intermediateDIR}/B_byte_nothresholding.nii.gz B_level1 # to get a mask B_level1_mask.nii.gz
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level1,$uh_level1 -i$foregroundThre -x1 B_level1.nii.gz B_level1
    # in level 2
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level2,$uh_level2 -i$foregroundThre -x2 A2B_affine_level2.nii.gz A2B_affine_level2
    run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level2,$uh_level2 -i$foregroundThre -x2 B_level2.nii.gz B_level2
    # in level 3
	if [ ${numLevels} -eq 3 ]; then
		run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level3,$uh_level3 -i$foregroundThre A2B_affine_level3.nii.gz A2B_affine_level3
		run CalculateGaborTextures -s$numGaborScales -o$numGaborOrientations -u$ul_level3,$uh_level3 -i$foregroundThre B_level3.nii.gz B_level3
	fi
	
    # generate list files
    #
    # changed on 11/23/2011, we utilize only the high- and mid-frequency Gabor
    # attributes in mid-resolution deformation and only high-frequency Gabor
    # attributes in fine-resolution deformation
    if [ $xSize -lt 120 ] || [ $ySize -lt 120 ] || [ $zSize -lt 80 ]; then
        run GenerateGaborListFile -s1 -o$numGaborOrientations A2B_affine_level1 Gabor_A_level1.lst
        run GenerateGaborListFile -s1 -o$numGaborOrientations B_level1 Gabor_B_level1.lst
    else
        run GenerateGaborListFile -s1 -o2 -R A2B_affine_level1 Gabor_A_level1.lst
        run GenerateGaborListFile -s1 -o2 -R B_level1 Gabor_B_level1.lst
        echo A2B_affine_level1_3dHori_F_imag.0_0.nii.gz >> Gabor_A_level1.lst
        echo A2B_affine_level1_3dVert_F_imag.0_0.nii.gz >> Gabor_A_level1.lst
        echo B_level1_3dHori_F_imag.0_0.nii.gz >> Gabor_B_level1.lst
        echo B_level1_3dVert_F_imag.0_0.nii.gz >> Gabor_B_level1.lst
        num1=4
        num2=6
        sed -i.bak -e "1s/${num1}/${num2}/g" Gabor_A_level1.lst
        sed -i.bak -e "1s/${num1}/${num2}/g" Gabor_B_level1.lst
    fi
    if [ ${zSize} -lt 4 ]; then
	    run GenerateGaborListFile -s2 -o$numGaborOrientations -H A2B_affine_level2 Gabor_A_level2.lst
	    run GenerateGaborListFile -s2 -o$numGaborOrientations -H B_level2 Gabor_B_level2.lst
    else
	    run GenerateGaborListFile -s2 -o$numGaborOrientations A2B_affine_level2 Gabor_A_level2.lst
	    run GenerateGaborListFile -s2 -o$numGaborOrientations B_level2 Gabor_B_level2.lst
    fi
    if [ ${numLevels} -eq 3 ]; then
	    if [ ${zSize} -lt 8 ]; then
		    run GenerateGaborListFile -s$numGaborScales -o$numGaborOrientations -H A2B_affine_level3 Gabor_A_level3.lst
		    run GenerateGaborListFile -s$numGaborScales -o$numGaborOrientations -H B_level3 Gabor_B_level3.lst
	    else
		    run GenerateGaborListFile -s$numGaborScales -o$numGaborOrientations A2B_affine_level3 Gabor_A_level3.lst
		    run GenerateGaborListFile -s$numGaborScales -o$numGaborOrientations B_level3 Gabor_B_level3.lst
	    fi
    fi
	
	# check gabor features, to remove the imaginary parts that might have been influenced by background noise (this part of code was added on 4/23/2013)
	if [ $xSize -lt 120 ] || [ $ySize -lt 120 ] || [ $zSize -lt 80 ]; then
		i=1
	else
		i=2
	fi
	while [ $i -le ${numLevels} ]; do
		NFeaturesExtracted=`cat Gabor_A_level$i.lst |sed -n 1p`
		NImagFeaturesExtracted=`echo "${NFeaturesExtracted}/2" | bc`
		echo ${NFeaturesExtracted} > GaborUsed_A_level$i.lst
		echo ${NFeaturesExtracted} > GaborUsed_B_level$i.lst
		
		NFeaturesUsed=0
		indf=1
		while [ ${indf} -le ${NImagFeaturesExtracted} ]; do
			ind_imag=`echo "2+(${indf}-1)*2" | bc`
			ind_real=`echo "3+(${indf}-1)*2" | bc`
			
			imagfeatureA=`cat Gabor_A_level$i.lst |sed -n ${ind_imag}p`
			realfeatureA=`cat Gabor_A_level$i.lst |sed -n ${ind_real}p`
			imagfeatureB=`cat Gabor_B_level$i.lst |sed -n ${ind_imag}p`
			realfeatureB=`cat Gabor_B_level$i.lst |sed -n ${ind_real}p`

			imagfeatureAsmooth=tmpAi.nii.gz
			realfeatureAsmooth=tmpAr.nii.gz
			imagfeatureBsmooth=tmpBi.nii.gz
			realfeatureBsmooth=tmpBr.nii.gz

			run ImageOperation -s auto ${imagfeatureA} ${imagfeatureAsmooth}
			run ImageOperation -s auto ${realfeatureA} ${realfeatureAsmooth}
			run ImageOperation -s auto ${imagfeatureB} ${imagfeatureBsmooth}
			run ImageOperation -s auto ${realfeatureB} ${realfeatureBsmooth}

			execute --allow_fail -- CheckTwoImages -f ${imagfeatureAsmooth} ${realfeatureAsmooth}
			sysflagA=`echo $?`
			execute --allow_fail -- CheckTwoImages -f ${imagfeatureBsmooth} ${realfeatureBsmooth}
			sysflagB=`echo $?`
			if [ ${sysflagA} -eq 200 ] || [ ${sysflagB} -eq 200 ]; then # only keep the real part, because the imaginary part might have been influenced by background noise.
				echo ${realfeatureA} >> GaborUsed_A_level${i}.lst
				echo ${realfeatureB} >> GaborUsed_B_level${i}.lst
				NFeaturesUsed=$(( ${NFeaturesUsed} + 1 ))
			else
				echo ${imagfeatureA} >> GaborUsed_A_level${i}.lst
				echo ${realfeatureA} >> GaborUsed_A_level${i}.lst
				echo ${imagfeatureB} >> GaborUsed_B_level${i}.lst
				echo ${realfeatureB} >> GaborUsed_B_level${i}.lst
				NFeaturesUsed=$(( ${NFeaturesUsed} + 2 ))
			fi
			
			indf=$(( ${indf} + 1 ))
		done
		sed -i.bak -e "1s/${NFeaturesExtracted}/${NFeaturesUsed}/g" GaborUsed_A_level${i}.lst
		sed -i.bak -e "1s/${NFeaturesExtracted}/${NFeaturesUsed}/g" GaborUsed_B_level${i}.lst		
		if [ ${NFeaturesUsed} -lt ${NFeaturesExtracted} ]; then
			echo ${NImagFeaturesExtracted} > GaborUsed_A_level${i}_realonly.lst
			echo ${NImagFeaturesExtracted} > GaborUsed_B_level${i}_realonly.lst
			grep real Gabor_A_level${i}.lst >> GaborUsed_A_level${i}_realonly.lst
			grep real Gabor_B_level${i}.lst >> GaborUsed_B_level${i}_realonly.lst
			\mv GaborUsed_A_level${i}_realonly.lst GaborUsed_A_level${i}.lst
			\mv GaborUsed_B_level${i}_realonly.lst GaborUsed_B_level${i}.lst
		fi
		i=$(( $i + 1 ))
	done 
	
	if [ $xSize -ge 120 ] && [ $ySize -ge 120 ] && [ $zSize -ge 80 ]; then
		if [ ${NFeaturesUsed} -ne ${NFeaturesExtracted} ]; then
			run GenerateGaborListFile -s1 -o2 -R A2B_affine_level1 GaborUsed_A_level1.lst
			run GenerateGaborListFile -s1 -o2 -R B_level1 GaborUsed_B_level1.lst
		else
			run cp -f Gabor_A_level1.lst GaborUsed_A_level1.lst
			run cp -f Gabor_B_level1.lst GaborUsed_B_level1.lst
		fi
	fi
fi


# ----------------------------------------------------------------------------
# change working directory
cd ${intermediateDIR}
sysflag=`echo $?`
[ ${sysflag} -eq 0 ] || {
    echo
    error "Failed to change to directory ${intermediateDIR}!"
    echo
    exit 1
}
[ ${verbose} -gt 0 ] && {
    echo
    echo "Changed to directory ${intermediateDIR}"
    echo
}


# ----------------------------------------------------------------------------
echo "Step 6:   Deformably register images via attribute matching and mutual-saliency weighting (be patient, may take tens of minutes)..."

flag_step6=1
if [ ${number_of_dimensions} == "2" ]; then
	if [ ${distBetweenControlPointsY} -eq 0 ]; then # if distBetweenControlPointsX not defined by user, we determine it automatically
		distBetweenControlPointsY=$(( ${xSize} / 25 ));
		if [ ${distBetweenControlPointsY} -lt 4 ]; then
			distBetweenControlPointsY=4  
		fi	
	fi    
	args="-r${numLevels} -b${distBetweenControlPointsY} -w${regularizationWeightMapped}"
    if [ ${keepIntermediateResultsOrNot} -eq 1 ]; then
        args="${args} -I${intermediateDIR}"
    fi 
    args="${args} ${attributeDIR}/A2B_affine_level1.nii.gz ${attributeDIR}/B_level1.nii.gz"
    args="${args} ${attributeDIR}/Gabor_"
    args="${args} A2B.nii.gz DField.nii.gz"

    echo -e "\nDeform2D $args\n"
    run Deform2D $args
else # -----------------------------------------------------------------------
    args="-b${distBetweenControlPointsX},${distBetweenControlPointsY},${distBetweenControlPointsZ} -p"
    args="${args} -r${numLevels} -C$mutualSaliencyOrNot -n$numDiscreteSamples -k${maxNumIterInEachResolution}"
    args="${args} -s${label_factor} -m${manipulationMethod} -f${additionOrComposition}"
    args="${args} -M2 -w1 -g${regularizationWeightMapped} -e$foregroundThre"
    args="${args} -F${fastApproximationOrNot} -S${similarityMeasure}"
	args="${args} -u${useMemory}"
    if [ $keepIntermediateResultsOrNot -eq 1 ]||[ $mutualSaliencyOrNot -eq 2 ]; then
        args="${args} -I${intermediateDIR}"
    fi 
    if [ ${inputmask} == 'NULL' ]; then
        args="${args} -a${attributeDIR}/B_level1_mask.nii.gz"
    else
	args="${args} -a${inputmask_fullname} -A"
    fi
    if [ ${initDeformation} != 'NULL' ]; then
        args="${args} -i${initDeformation_DeformableOnly}"
    fi
    args="${args} ${attributeDIR}/A2B_affine_level1.nii.gz ${attributeDIR}/B_level1.nii.gz"
    args="${args} ${attributeDIR}/GaborUsed_"
    args="${args} A2B.nii.gz DField.nii.gz"

    echo -e "\nDeform3D $args\n"
    run Deform3D $args
fi
flag_step6=0

# ----------------------------------------------------------------------------
# Check if step 6 finished successfully, if not, it is most likely because of the shortage of memory
if [ ! -f DField.nii.gz ]; then
	errormemoryshortage
	exit 1
fi

# ----------------------------------------------------------------------------
if [ ${affineOrNot} != "0" ]||[ ${initAffineMatrix} != 'NULL' ]; then
    echo "Step 7:   Combine the affine and deformable transformations into an unified deformation..."
    run CombineTransforms -c -f ${inputImgA_fullname} -t ${inputImgB_fullname} ${MatA2BAffine} DField.nii.gz ${deformationFieldA2B_fullname}
else
    echo "Step 7:   Skip the combination of affine and deformable transformations as no affine registration was performed."
    run mv -f DField.nii.gz ${deformationFieldA2B_fullname}
fi

# ----------------------------------------------------------------------------
echo "Step 8:   Warp the input image and write output files..."

cd ${outputImgA2B_path}
sysflag=`echo $?`
[ ${sysflag} -eq 0 ] || {
    echo
    error "Failed to change to directory ${outputImgA2B_path}!"
    echo
    exit 1
}
[ ${verbose} -gt 0 ] && {
    echo
    echo "Changed to directory ${outputImgA2B_path}"
    echo
}

run ApplyTransform -v ${inputImgA_fullname} ${deformationFieldA2B_fullname} ${outputImgA2B_fullname}

if [ $mutualSaliencyOrNot -eq 2 ]; then
    run cp -f ${intermediateDIR}/MutualSaliencyMap_level1.nii.gz MutualSaliencyMap_${prefixA2B}.nii.gz
fi

echo
echo "The registered image has been saved to file $outputImgA2B, deformation to file $deformationFieldA2B"
echo
echo


timeProgramEnd=`date +%s`
timeElapsed_inSeconds=`expr $timeProgramEnd - $timeProgramBegin`
timeElapsed_inMinutes=`echo "scale=2; $timeElapsed_inSeconds/60" | bc`
echo "Total time used: $timeElapsed_inMinutes minutes."
echo
echo


################################
#
### Calculate Jacobian determinant
#
################################

if [ $Jacobian != 'NULL' ]; then
    echo "Post-step: Calculate Jacobian determinant of deformation field..."
    run CalculateJacobianMap ${deformationFieldA2B_fullname} ${Jacobian_fullname} -f ${inputImgA_fullname} -t ${inputImgB_fullname}
fi


################################
#
### Calculate RAVENS maps
#
################################

if [ $RAVENS != 'NULL' ]; then
    echo "Post-step: Calculate RAVENS maps..."
    run CalculateRavensMaps -m ${labelValues} ${LabelMap_fullname} ${inputImgA_fullname} ${deformationFieldA2B_fullname} ${RAVENS_path}/${RAVENS_prefix}
fi


################################
#
### Warp another image
#
################################

if [ ${WarpedImage} != 'NULL' ]; then
    echo "Post-step: Warp another image using obtained deformation..."
    if [ ${interpolationWarp} == 0 ]; then  # nearest neighbor interpolation
        run ApplyTransform -v -n ${LabelMap_fullname} ${deformationFieldA2B_fullname} ${WarpedImage_fullname}
    else
        run ApplyTransform -v ${LabelMap_fullname} ${deformationFieldA2B_fullname} ${WarpedImage_fullname}
    fi
fi






###############################
#
### At the end, prompt possible failure message for registration (results fail, not program fail)
#
###############################
#if [ ${affineOrNot} != 0 ]&[ "`echo ${chosencc} '<' 0.5 |bc -l`" -eq 1 ]; then
if [ ${affineOrNot} != 0 ]&[ "`echo ${chosencc} '<' 0.25 |bc -l`" -eq 1 ]; then
	echo -e "\e[00;31m ------------Warning------------- \e[00m"
	echo -e "\e[00;31m Registration results may be wrong (although dramms program finishes successfully). \e[00m"
	echo -e "\e[00;31m This is usually the case when two input images are largely different in structures/contents, that even affine registration may fail. \e[00m"
	echo ""
	echo -e "\e[00;31m One possible solution is to re-do affine registration outside dramms scope. \e[00m"
	echo -e "\e[00;31m After having obtained a reasonable affine result (please visualize and check), \e[00m"
	echo -e "\e[00;31m Then re-run dramms with the obtained affine matrix as an initialization (via the '-d' option). Note that we only recoginize affine matrix in the FSL flirt convention, with the .mat extension.\e[00m"
	echo -e "\e[00;31m -------------------------------- \e[00m"
	echo ""
fi


exit 0
