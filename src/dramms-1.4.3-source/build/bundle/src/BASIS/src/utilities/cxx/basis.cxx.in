/**
 * @file  basis.cxx
 * @brief BASIS utilities of @PROJECT_NAME@ project of @PROJECT_PACKAGE@ package.
 *
 * @note The basis.cxx module was automatically generated by BASIS from the
 *       template file basis.cxx.in which is part of the BASIS installation.
 *
 * Copyright (c) 2011, 2012 University of Pennsylvania. All rights reserved.<br />
 * See http://www.rad.upenn.edu/sbia/software/license.html or COPYING file.
 *
 * Contact: SBIA Group <sbia-software at uphs.upenn.edu>
 */

#include <map>

#include <@PREFIX@/basis.h>


// acceptable in .cxx file
using namespace std;
using namespace basis;


@PROJECT_NAMESPACE_CXX_BEGIN@


// ===========================================================================
// constants
// ===========================================================================

// ---------------------------------------------------------------------------
// project attributes
const char* PROJECT = "@PROJECT_ID@";
const char* VERSION = "@PROJECT_VERSION@";
const char* RELEASE = "@PROJECT_RELEASE@";

const unsigned int VERSION_MAJOR = @PROJECT_VERSION_MAJOR@;
const unsigned int VERSION_MINOR = @PROJECT_VERSION_MINOR@;
const unsigned int VERSION_PATCH = @PROJECT_VERSION_PATCH@;

const char* COPYRIGHT = "@PROJECT_COPYRIGHT@";
const char* LICENSE   = "@PROJECT_LICENSE@";
const char* CONTACT   = "@PROJECT_CONTACT@";

// ===========================================================================
// local helper functions
// ===========================================================================

/**
 * @brief Determine if this is the built or the installed executable.
 *
 * @returns Whether the executable was executed from within the build tree.
 */
static inline bool executing_in_build_tree()
{
    // get executable path relative to top directory of build tree
    string rel_path = os::path::relpath(
            // directory of this executable
            os::exedir(),
            // The following path is the absolute path of the top directory of the build
            // tree in which the software was built. It can be used to determine whether
            // an executable is executing from within the build tree rather than an
            // installation. Given that we tend to build software in a directory with the
            // prefix "-build", but never choose such directory for the installation prefix,
            // a check whether or not the location of the executable file is inside this
            // build tree is enough to know whether or not it is executed from within the
            // build tree or an installation.
            os::path::realpath("@BUILD_ROOT_PATH_CONFIG@"));
    // return whether executable directory is inside the build tree or not
    return !(rel_path == "" || rel_path == "." ||
            (rel_path.substr(0, 2) == ".." && (rel_path.size() == 2 || rel_path[2] == '/')));
}

// ===========================================================================
// class: ExecutableTargetInfo (declaration)
// ===========================================================================

// The definition of the class methods can be found at the end of this file.

/**
 * @brief Provides information about executable build targets.
 *
 * @sa IExecutableTargetInfo
 */
class ExecutableTargetInfo : public basis::util::IExecutableTargetInfo
{
    // -----------------------------------------------------------------------
    // typedefs
private:

    typedef std::map <std::string, std::string> MapType;
    typedef MapType::const_iterator             MapIterator;

    // -----------------------------------------------------------------------
    // construction / destruction
private:

    /**
     * @brief Constructor.
     *
     * Initializes the data members. The initialization code is in particular
     * generated by BASIS during the configuration of the build system.
     */
    ExecutableTargetInfo();

    /// @brief Destructor.
    ~ExecutableTargetInfo() {}

public:

    /**
     * @brief Get static instance of this module.
     *
     * @attention This method is not thread-safe!
     *
     * @return Static instance of this class.
     */
    static const ExecutableTargetInfo* instance();

    // -----------------------------------------------------------------------
    // public interface
public:

    std::string targetuid(const std::string& target) const;
    bool istarget(const std::string& target) const;
    std::string basename(const std::string& target) const;
    std::string dirname(const std::string& target) const;

    // -----------------------------------------------------------------------
    // unsupported methods
private:

    /**
     * @brief Copy constructor.
     *
     * @note Intentionally not implemented.
     */
    ExecutableTargetInfo(const ExecutableTargetInfo&);

    /**
     * @brief Assignment operator.
     *
     * @note Intentionally not implemented.
     */
    void operator=(const ExecutableTargetInfo&);

    // -----------------------------------------------------------------------
    // members
private:

    /// Maps build target names to executable file names.
    MapType _exec_names;
    /// Maps build target names to output directories in build tree.
    MapType _build_dirs;
    /// Maps build target names to installation directories relative to
    /// installation prefix as returned by GetInstallationPrefix().
    MapType _install_dirs;

}; // class ExecutableTargetInfo

// ===========================================================================
// package directories
// ===========================================================================

/**
 * @brief Get absolute path of installation directory.
 *
 * This function returns the absolute path of the installation prefix path.
 * If the installation was not moved after a "make install", the returned
 * directory corresponds to the value of the INSTALL_PREFIX CMake variable
 * as specified during the build of the executable file. Note, however,
 * that even when the installation tree was moved after the configuration
 * and build of the software, the correct path is returned as long as the
 * relative directory structure of the installation tree is maintained.
 * This is because the path is determined relative to the directory of the
 * executable itself, knowning in which path this executable is located
 * relative to the INSTALL_PREFIX.
 *
 * @note If the executable is executed from within the build tree, the
 *       returned path will not be correct. Therefore, only use this
 *       function when executing_in_build_tree() returns false. Otherwise,
 *       the configured absolute paths which are valid for the build tree
 *       have to be used. Note that the build tree is not supposed to be
 *       relocatable in any case as it is only a temporary directory tree
 *       and CMake requires it to be not moved anywhere else.
 *
 * @returns Absolute path of top directory of installation tree.
 */
static string install_prefix()
{
#ifdef LIBEXEC
    return os::path::join(os::exedir(), "@LIBEXEC_PATH_PREFIX_CONFIG@");
#else
    return os::path::join(os::exedir(), "@RUNTIME_PATH_PREFIX_CONFIG@");
#endif
}

// ---------------------------------------------------------------------------
string bindir()
{
    if (executing_in_build_tree()) {
        return "@RUNTIME_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(install_prefix(), "@RUNTIME_PATH_CONFIG@");
    }
}

// ---------------------------------------------------------------------------
string libexecdir()
{
    if (executing_in_build_tree()) {
        return "@LIBEXEC_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(install_prefix(), "@LIBEXEC_PATH_CONFIG@");
    }
}

// ---------------------------------------------------------------------------
string libdir()
{
    if (executing_in_build_tree()) {
        return "@LIBRARY_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(install_prefix(), "@LIBRARY_PATH_CONFIG@");
    }
}

// ---------------------------------------------------------------------------
string datadir()
{
    if (executing_in_build_tree()) {
        return "@DATA_BUILD_PATH_CONFIG@";
    } else {
        return os::path::join(install_prefix(), "@DATA_PATH_CONFIG@");
    }
}

// ===========================================================================
// executable information
// ===========================================================================

// ---------------------------------------------------------------------------
void print_contact(const char* contact)
{
    basis::util::print_contact(contact != NULL ? contact : CONTACT);
}

// ---------------------------------------------------------------------------
void print_version(const char* name, const char* version, const char* project, const char* copyright, const char* license)
{
    basis::util::print_version(name,
                               version   != NULL ? version   : RELEASE,
                               project   != NULL ? project   : PROJECT,
                               copyright != NULL ? copyright : COPYRIGHT,
                               license   != NULL ? license   : LICENSE);
}

// ---------------------------------------------------------------------------
string targetuid(const string& name)
{
    return basis::util::targetuid(name, ExecutableTargetInfo::instance());
}

// ---------------------------------------------------------------------------
bool istarget(const string& name)
{
    return basis::util::istarget(name, ExecutableTargetInfo::instance());
}

// ---------------------------------------------------------------------------
string exepath(const string& name)
{
    return basis::util::exepath(name, ExecutableTargetInfo::instance());
}

// ---------------------------------------------------------------------------
string exename(const std::string& name)
{
    return basis::util::exename(name, ExecutableTargetInfo::instance());
}

// ---------------------------------------------------------------------------
string exedir(const std::string& name)
{
    return basis::util::exedir(name, ExecutableTargetInfo::instance());
}

// ===========================================================================
// command execution
// ===========================================================================

// ---------------------------------------------------------------------------
int execute(const string& cmd, bool quiet, ostream* out,
            bool allow_fail, int verbose, bool simulate)
{
    return basis::util::execute(cmd, quiet, out, allow_fail, verbose, simulate,
                                ExecutableTargetInfo::instance());
}

// ---------------------------------------------------------------------------
int execute(vector<string> args, bool quiet, ostream* out,
            bool allow_fail, int verbose, bool simulate)
{
    return basis::util::execute(args, quiet, out, allow_fail, verbose, simulate,
                                ExecutableTargetInfo::instance());
}

// ===========================================================================
// class: ExecutableTargetInfo (definition)
// ===========================================================================

// ---------------------------------------------------------------------------
const ExecutableTargetInfo* ExecutableTargetInfo::instance()
{
    static ExecutableTargetInfo instance;
    return &instance;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::targetuid(const string& target) const
{
    // empty(, invalid) target name remains unchanged
    if (target.empty()) return "";
    // in case of a leading namespace separator, do not modify target name
    if (target[0] == '.') return target;
    // project namespace
    string prefix = string("@PROJECT_NAMESPACE_CMAKE@");
    // try prepending namespace or parts of it until target is known
    for (;;) {
        if (_exec_names.find(prefix + "." + target) != _exec_names.end()) {
            return prefix + "." + target;
        }
        string::size_type pos = prefix.rfind('.');
        if (pos == string::npos) break;
        prefix = prefix.substr(0, pos);
    }
    // otherwise, return target name unchanged
    return target;
}

// ---------------------------------------------------------------------------
bool ExecutableTargetInfo::istarget(const string& target) const
{
    if (target.empty()) return false;
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = targetuid(target);
    return _exec_names.find(uid) != _exec_names.end();
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::basename(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = targetuid(target);
    MapIterator it = _exec_names.find(uid);
    if (it == _exec_names.end ()) return "";
    return it->second;
}

// ---------------------------------------------------------------------------
string ExecutableTargetInfo::dirname(const string& target) const
{
    if (target.empty()) return "";
    string uid;
    if (target[0] == '.') uid = target.substr(1);
    else uid = targetuid(target);
    if (executing_in_build_tree()) {
        MapIterator it = _build_dirs.find(uid);
        if (it == _build_dirs.end()) return "";
        #if defined CMAKE_INTDIR
            // this subdirectory is used by CMake generators for IDEs such as Visual Studio
            return os::path::join(it->second, CMAKE_INTDIR);
        #else
            return it->second;
        #endif
    } else {
        MapIterator it = _install_dirs.find(uid);
        if (it == _install_dirs.end()) return "";
        return os::path::join(install_prefix(), it->second);
    }
}

// ---------------------------------------------------------------------------
ExecutableTargetInfo::ExecutableTargetInfo()
{
    @EXECUTABLE_TARGET_INFO@
}


@PROJECT_NAMESPACE_CXX_END@ // end of namespaces
